<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 姚 成 健</title>
        <link>http://yaochengjian.com/posts/</link>
        <description>Recent content in Posts on 姚 成 健</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-hans</language>
        <lastBuildDate>Fri, 06 Mar 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="http://yaochengjian.com/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>23 - [JS全解]JS函数</title>
            <link>http://yaochengjian.com/posts/23/</link>
            <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/23/</guid>
            <description>1.四种方式定义函数 1.定义一个函数
具名函数(具有名字的函数)function 函数名(形式参数1,形式参数2){语句return 返回值}匿名函数上面的具名函数,去掉函数就是匿名函数箭头函数如果只有一个形参,可以省略括号,箭头后面只有一句话默认是(return x + x)fn = x =&amp;gt; x+x;否则fn = (x+y) =&amp;gt; {console.log(1),return x+y;}()起来js会认为是一个整体fn = name =&amp;gt; ({name:&#39;chengjian&#39;})用构造函数let f = new Function(&#39;x&#39;,&#39;y&#39;,&#39;return x+y&#39;)基本没人用，但是能让你知道函数是谁构造的所有的函数都是Function构造出来的包括Object、Array、Function也是2.调用时机 代码1(定时器是异步,它需要等待同步执行完后执行)let在外头,每次for循环,每次循环都是一个作用域,新的值都会覆盖外面let的值let i = 0;for(i = 0;i &amp;lt; 6;i++){setTimeout(()=&amp;gt;{console.log(i)});}let在里头,每次for循环都会形成一个let的作用域,循环多少次就会有多少个作用域for(let i = 0;i &amp;lt; 6;i++&amp;gt;){setTimeout(()=&amp;gt;{console.log(i)});}3.作用域:就近原则 &amp;amp; 闭包 作用域 : 每个函数执行都会形成一个私有作用域</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1四种方式定义函数font"><font color=red>1.四种方式定义函数</font></h3>
<p>1.定义一个函数</p>
<pre><code>具名函数(具有名字的函数)
    function 函数名(形式参数1,形式参数2){
        语句
        return 返回值
    }

匿名函数
    上面的具名函数,去掉函数就是匿名函数

箭头函数
    如果只有一个形参,可以省略括号,箭头后面只有一句话默认是(return x + x)
        fn = x =&gt; x+x;

    否则
        fn = (x+y) =&gt; {console.log(1),return x+y;}

    ()起来js会认为是一个整体
        fn = name =&gt; ({name:'chengjian'})

用构造函数
    let f = new Function('x','y','return x+y')
    基本没人用，但是能让你知道函数是谁构造的
    所有的函数都是Function构造出来的
    包括Object、Array、Function也是
</code></pre><h3 id="2调用时机">2.调用时机</h3>
<pre><code>代码1(定时器是异步,它需要等待同步执行完后执行)
    let在外头,每次for循环,每次循环都是一个作用域,新的值都会覆盖外面let的值
    let i = 0;
    for(i = 0;i &lt; 6;i++){
        setTimeout(()=&gt;{console.log(i)});
    }

    let在里头,每次for循环都会形成一个let的作用域,循环多少次就会有多少个作用域
    for(let i = 0;i &lt; 6;i++&gt;){
        setTimeout(()=&gt;{console.log(i)});
    }
</code></pre><h3 id="3作用域就近原则--闭包">3.作用域:就近原则 &amp; 闭包</h3>
<p>作用域 : 每个函数执行都会形成一个私有作用域<br>
闭包 : 如果一个函数用到了外部的变量,那么这个函数加这个变量就叫做闭包</p>
<h3 id="4参数和返回值">4.参数和返回值</h3>
<p>参数</p>
<pre><code>1.形式参数的意思就是非实际参数
    function add(x,y){
        return x+y;
    }

2.其中x 和 y就是形参，因为并不是实际的参数，调用add(1,2)是实际参数，会被赋值给x,y

3.形参可认为是变量声明

4.let x = {'apple' : '苹果'};
  function fn(obj){
      obj.banana = '香蕉';
  }
  fn(x);
  如果实际参数是一个对象,就会把地址传给obj。基本类型数据简单,则会以赋值值形式传递给obj
</code></pre><p>返回值</p>
<pre><code>每个函数都有返回值
    function hi(){
        console.log('hi');
    }
    hi();
    没写retrun,所以返回值是undefined
</code></pre><h3 id="5递归调用栈与爆栈">5.递归、调用栈与爆栈</h3>
<pre><code>递归函数(阶乘)
    function f(n){
        return n !== 1 ? n * f(n-1) : 1
    }

理解递归
    f(4) = 4 * f(3)
    f(3) = 3 * f(2)
    f(2) = 2 * f(1)
    f(1) = 1
先递进,在回归
</code></pre><p>调用 m 次,就会压 m 次栈,最后导致爆栈<br>
<img src="../../images/%E8%B0%83%E7%94%A8%E6%A0%88.png" alt=""></p>
<h3 id="6this">6.this</h3>
<p>arguments 和 this : 每个函数都有,除了箭头函数<br>
1.arguments 是一个伪数组</p>
<pre><code>改变 this 指向
    function fn(){
        'use strict'
        console.log(this);
    }
1.fn.call(1) 如果你传的不是对象,那么 js 会默认帮你封装成一个对象
2.在函数内添加 'use strict'严格模式,你传什么this就是什么
3.fn.call(undefined) js会默认指向window
</code></pre><h3 id="7call-bind-apply-指定-this如果你传的不是对象那么-js-会默认帮你封装成一个对象">7.call 、bind 、apply 指定 this(如果你传的不是对象,那么 js 会默认帮你封装成一个对象)</h3>
<p>call</p>
<pre><code>两种调用
    let person = {
        name : 'frank',
        sayHi(){
            console.log(this.name);
        }
    }
    person.sayHi() 小白调用法
    person.sayHi.call(person) 大师调用法

应该学习哪种?
    1.学习大师调用法,因为小白调用法你早就会了
    2.从这里开始,默认用大师调用法

例1:(为什么要多写一个undefined)
    function add(x,y){
        return x + y
    }
    add.call(undefined,1,2)
    1.因为第一个参数要作为this
    2.但是代码里没有用this,所以只能用undefined占位,其实用null也可以
</code></pre><p>bind(会返回一个新的函数,但是它里面 this 指向是同一个对象)</p>
<pre><code>    let person = {
        name = 'chengjian'
    }
    function fn(age){
        console.log(age);
        return this;
    }
    let fn1 = fn.bind(person,10); //bind里面的实参优先级会大于fn1(10)的实参
    let fn2 = fn.bind(person);
</code></pre><p>apply(它的第一个参数是 this 指向,第二个则是以数组形式传递,函数接收时候要同等参数接收)</p>
<pre><code>    var person = {
    fullName: function(city, country) {
        return this.firstName + &quot; &quot; + this.lastName + &quot;,&quot; + city + &quot;,&quot; + country;
    }
    }
    var person1 = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;
    }
    person.fullName.apply(person1, [&quot;Oslo&quot;, &quot;Norway&quot;]);

例子1(找出字符串中的最大数,可以用apply)
    let str = '123456789';
    Math.max.apply(null,[...str]);
</code></pre><h3 id="8箭头函数this-是根据它的上级作用域而决定的没有-arguments">8.箭头函数(this 是根据它的上级作用域而决定的)(没有 arguments)</h3>
<pre><code>this
    function fn(){
        console.log(this);
        a = () =&gt; {
            console.log(this);
        }
    }
    fn.call({});

argumnets
    a = () =&gt; {
        console.log(arguments);
    }
</code></pre><h3 id="9立即执行函数推荐使用">9.立即执行函数(推荐使用!)</h3>
<pre><code>1.ES5时代，为了得到局部变量,必须引入一个函数,但是声明一个具名函数会映射到window上,最终发现!声明一个匿名函数在前面添加个运算符(! | ~ | + | -),就可以立即执行,而且不会映射到window上面
    !function(){
        var a = 1;
        console.log(a);
    }()
</code></pre>]]></content>
        </item>
        
        <item>
            <title>24 - [JS全解]字符串中API</title>
            <link>http://yaochengjian.com/posts/24/</link>
            <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/24/</guid>
            <description>分割字符串 split(获得一个数组)   let str = &#39;1,2,3,4,5,6&#39;;let arr1 = str.split(&#39;,&#39;); 以&#39;,&#39;号形式分割let arr2 = str.split(&#39;&#39;); 以&#39;&#39;形式分割拼接字符串 concat(获得新的字符串)   let str1 = &#39;abcd&#39;;let str2 = &#39;efgh&#39;;let str3 = str1.concat(str1);截取字符串 substring(获得新的字符串)   let str1 = &#39;你好啊!我的名字叫~~~&#39;;let str2 = str1.substring(0,1); 索引0开始,截取到索引1(不包括索引1)let str3 = str1.substring(3,6); 索引0开始,截取到索引1(不包括索引1)截取字符串 slice   let str1 = &#39;ABCDEFG&#39;;let str2 = str1.slice(0) 拷贝字符串let str3 = str1.slice(2,5) 索引2开始，到索引5结束(不包括索引5)返回指定位置的字符串 charAt   let str1 = &#39;ABCEDFG&#39;;let s = str1.</description>
            <content type="html"><![CDATA[<ol>
<li>分割字符串 split(获得一个数组)</li>
</ol>
<pre><code>    let str = '1,2,3,4,5,6';
    let arr1 = str.split(','); 以','号形式分割
    let arr2 = str.split('');  以''形式分割
</code></pre><ol start="2">
<li>拼接字符串 concat(获得新的字符串)</li>
</ol>
<pre><code>    let str1 = 'abcd';
    let str2 = 'efgh';
    let str3 = str1.concat(str1);
</code></pre><ol start="3">
<li>截取字符串 substring(获得新的字符串)</li>
</ol>
<pre><code>    let str1 = '你好啊!我的名字叫~~~';
    let str2 = str1.substring(0,1); 索引0开始,截取到索引1(不包括索引1)
    let str3 = str1.substring(3,6); 索引0开始,截取到索引1(不包括索引1)
</code></pre><ol start="4">
<li>截取字符串 slice</li>
</ol>
<pre><code>    let str1 = 'ABCDEFG';
    let str2 = str1.slice(0) 拷贝字符串
    let str3 = str1.slice(2,5) 索引2开始，到索引5结束(不包括索引5)
</code></pre><ol start="5">
<li>返回指定位置的字符串 charAt</li>
</ol>
<pre><code>    let str1 = 'ABCEDFG';
    let s = str1.charAt(3); 根据字符串索引返回你想要的字符
</code></pre><ol start="6">
<li>返回 Unicode 编码 charCodeAt 和 fromCharCode</li>
</ol>
<pre><code>    let str1 = 'ABCDEFG';
    let n = str1.charCodeAt(3); 根据字符串索引返回你想要的字符的Unicode编码

    String.fromCharCode(33);  根据编码返回相应的字符
</code></pre><ol start="7">
<li>字符串替换 replace(regexp/substr,str)</li>
</ol>
<pre><code>    let str = `大家好!
    hello
    `
    str.replace(/\n/g,'&lt;br/&gt;');
</code></pre>]]></content>
        </item>
        
        <item>
            <title>25 - [JS全解]JS运算符</title>
            <link>http://yaochengjian.com/posts/25/</link>
            <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/25/</guid>
            <description>1.算术运算符 number 运算
1.加减乘除(+ - * /)2.取余(%)3.指数(**)7 ** 2 =&amp;gt; 七的平方7 *** 3 =&amp;gt; 七的三次方4.自增自减自增在后,先赋值,后计算自增在前,先计算,后赋值x++x--++x--x5.求值运算符+6.负数运算符-string 运算
1.字符串只支持一个 + 号的运算,其它符号都不支持2.任何东西+字符串都 = 字符串</description>
            <content type="html"><![CDATA[<h3 id="1算术运算符">1.算术运算符</h3>
<p>number 运算</p>
<pre><code>1.加减乘除(+ - * /)

2.取余(%)

3.指数(**)
    7 ** 2 =&gt; 七的平方
    7 *** 3 =&gt; 七的三次方

4.自增自减
自增在后,先赋值,后计算
自增在前,先计算,后赋值
    x++
    x--
    ++x
    --x

5.求值运算符+

6.负数运算符-

</code></pre><p>string 运算</p>
<pre><code>1.字符串只支持一个 + 号的运算,其它符号都不支持
2.任何东西+字符串都 = 字符串
</code></pre>]]></content>
        </item>
        
        <item>
            <title>26 - [JS全解]JS各种类型转换机制</title>
            <link>http://yaochengjian.com/posts/26/</link>
            <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/26/</guid>
            <description>1.Number 和 isNaN 类型详细解读 数据类型详细剖析
1.Number (null &#39;&amp;rsquo; &#39; &#39; false [])转了都是 0
Number(&amp;lsquo;13px&amp;rsquo;) Number 如果当前字符串出现任意一个非有效数字字符,结果都为 NaN
2.isNaN 检测机制(数字类型只有 NaN 不是有效数字,其余都是有效数字)
Number 转换也是这种机制
首先会检测当前值是否为数字类型,如果不是,浏览器会默认把值转换为数字类型1.基本类型转换为数字 : 直接使用Number这个方法转换2.引用类型值转换为数字 : 先用toString()转换为数字,然后再把字符串调取Number转换为数字-对象 : 所有对象toString都是 &#39;[object object]&#39;-函数 : (function fn(){}).toString() -&amp;gt; &#39;function fn(){}&#39;-数组 : [12].toString() -&amp;gt; &#39;12&#39; -&amp;gt; Number(&#39;12&#39;) -&amp;gt; 12[12,13].toString() -&amp;gt; &#39;12,13&#39; -&amp;gt; Number(&#39;12,13&#39;) -&amp;gt; NaN-正则 : /^89$/.toString() -&amp;gt; &#39;/^89$/&#39; -&amp;gt; Number(&#39;/^89$/&#39;) -&amp;gt; NaN2.parseInt / parseFloat 1.</description>
            <content type="html"><![CDATA[<h3 id="1number-和-isnan-类型详细解读">1.Number 和 isNaN 类型详细解读</h3>
<p>数据类型详细剖析<br>
1.Number (null '&rsquo; ' ' false [])转了都是 0<br>
   Number(&lsquo;13px&rsquo;) Number 如果当前字符串出现任意一个非有效数字字符,结果都为 NaN</p>
<p>2.isNaN 检测机制(数字类型只有 NaN 不是有效数字,其余都是有效数字)<br>
   Number 转换也是这种机制</p>
<pre><code>首先会检测当前值是否为数字类型,如果不是,浏览器会默认把值转换为数字类型

1.基本类型转换为数字 : 直接使用Number这个方法转换

2.引用类型值转换为数字 : 先用toString()转换为数字,然后再把字符串调取Number转换为数字

    -对象 : 所有对象toString都是 '[object object]'

    -函数 : (function fn(){}).toString() -&gt; 'function fn(){}'

    -数组 : [12].toString() -&gt; '12' -&gt; Number('12') -&gt; 12
            [12,13].toString() -&gt; '12,13' -&gt; Number('12,13') -&gt; NaN

    -正则 : /^89$/.toString() -&gt; '/^89$/' -&gt; Number('/^89$/') -&gt; NaN
</code></pre><h3 id="2parseint--parsefloat">2.parseInt / parseFloat</h3>
<p>1.等同与 Number,也是为了把其它类型的值转换为数字类型</p>
<p>parseInt : 把一个字符串中的整数部分解析出来,字符串第一位开始找,是有效数字就找下去,不是则返回 NaN,停止</p>
<p>parseFloat : 把一个字符串中小数部分解析出来,字符串第一位开始找,字符串第一位开始找,是有效数字就找下去,不是则返回 NaN,停止</p>
<p>2.基本类型就直接从左到右找,第一位出现无效数字就会返回 NaN</p>
<p>3.引用类型会 toString(),然后从第一位开始找</p>
<h3 id="3--运算符">3. + 运算符</h3>
<p>1.所有东西与字符串相加都等于字符串</p>
<p>2.基本类型相加,会 Numbe 之后在相加(除了字符串)</p>
<p>3.引用类型相加,会 toString()之后在相加</p>
<h3 id="4----运算符null-不等于任何值">4. == | != 运算符(null 不等于任何值)</h3>
<pre><code>1.基本类型比较 : 不同的基本类型会 Number() 之后再比较(除了null),相同则直接比较

2.引用类型比较 : 是比较该 16 进制内存地址

3.引用类型 与 基本类型比较,会把引用类型toString()在比较，双方为基本类型了,又会重复第一步
</code></pre>]]></content>
        </item>
        
        <item>
            <title>27 - [JS编程接口]DOM编程</title>
            <link>http://yaochengjian.com/posts/27/</link>
            <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/27/</guid>
            <description>1.获取元素的 API 1.window.idxxx 或者直接 idxxx 一个标签拥有 id,直接用这种方式就可以获取
2.document.getElementById(&amp;lsquo;xxx&amp;rsquo;) 通过 id 获取该标签
3.document.getElementsByTagName(&amp;lsquo;div&amp;rsquo;) 通过标签获取属性,是一个伪数组
4.document.getElementsByClassName(&amp;lsquo;red&amp;rsquo;) 通过类获取该标签,是一个伪数组
5.document.querySelector(&#39;#id&amp;rsquo;)
6.document.querySelectorAll(&#39;.red&amp;rsquo;)
2.获取特定元素 1.获取html元素document.documentElement2.获取head元素document.head3.获取body元素document.body4.获取窗口(窗口不是元素,是一个对象)window5.获取所有元素(第六个falsy值)因为这个东西是ie发明的,在ie里面是真值,其它浏览器是假值document.all3.节点 1. element.nodeType 得到一个数字2. 1表示元素Element,也叫标签Tag3. 3表示文本Text4. 8表示注释Comment5. 9表示文档document记住2和3即可4.节点的增删改查 1.增加
1.创建一个标签节点let div1 = document.createElement(&#39;div&#39;);2.创建一个文本节点text1 = document.createTextNode(&#39;你好&#39;);3.标签里面插入文本div1.appendChild(text1); 如果页面本来存在标签,会擦掉在插入你想要位置div1.innerText = &#39;你好&#39; 或者 div1.textContent = &#39;你好&#39;但是不能用div1.appendChild(&#39;你好&#39;)2.删除
1.两种方法node.prototype提供方法(必须要父亲来删除)let div1 = document.</description>
            <content type="html"><![CDATA[<h3 id="1获取元素的-api">1.获取元素的 API</h3>
<p>1.window.idxxx 或者直接 idxxx 一个标签拥有 id,直接用这种方式就可以获取<br>
2.document.getElementById(&lsquo;xxx&rsquo;) 通过 id 获取该标签<br>
3.document.getElementsByTagName(&lsquo;div&rsquo;) 通过标签获取属性,是一个伪数组<br>
4.document.getElementsByClassName(&lsquo;red&rsquo;) 通过类获取该标签,是一个伪数组<br>
5.document.querySelector('#id&rsquo;)<br>
6.document.querySelectorAll('.red&rsquo;)</p>
<h3 id="2获取特定元素">2.获取特定元素</h3>
<pre><code>1.获取html元素
document.documentElement

2.获取head元素
document.head

3.获取body元素
document.body

4.获取窗口(窗口不是元素,是一个对象)
window

5.获取所有元素(第六个falsy值)
因为这个东西是ie发明的,在ie里面是真值,其它浏览器是假值
document.all
</code></pre><h3 id="3节点">3.节点</h3>
<pre><code>1. element.nodeType 得到一个数字
2. 1表示元素Element,也叫标签Tag
3. 3表示文本Text
4. 8表示注释Comment
5. 9表示文档document
记住2和3即可
</code></pre><h3 id="4节点的增删改查">4.节点的增删改查</h3>
<p>1.增加</p>
<pre><code>1.创建一个标签节点
    let div1 = document.createElement('div');

2.创建一个文本节点
    text1 = document.createTextNode('你好');

3.标签里面插入文本
    div1.appendChild(text1); 如果页面本来存在标签,会擦掉在插入你想要位置
    div1.innerText = '你好' 或者 div1.textContent = '你好'
    但是不能用div1.appendChild('你好')
</code></pre><p>2.删除</p>
<pre><code>1.两种方法
node.prototype提供方法(必须要父亲来删除)
    let div1 = document.createElement('div');
    div.parentNode.removeChild(div1);

element.prototype提供方法(可以自己删除自己)
    let div1 = document.createElement('div');
    div.remove();
</code></pre><p>3.改属性</p>
<pre><code>1.改class : div.styleName = 'red blue'(会覆盖之前的)
2.改class : div.classList.add('red') 添加一个类属性
3.添加属性 : div.setAttribute('class','div1')
4.获取属性 : div.getAttribute('class')
</code></pre><p>改时间处理函数</p>
<pre><code>div.onclick 默认为null
1.默认点击div不会有任何时间发送
2.但是如果你把div.onclick 改为一个函数fn
3.那么点击div的时候,浏览器就会调用这个函数
4.并且是这样调用的fn.call(div,event)
5.div会被当做this
6.event则包含了点击事件的所有信息,如坐标等
</code></pre><p>4.查</p>
<pre><code>1.查爸爸
    div.parentNode 或者 div.parentElement

2.查爷爷
    div.parentNode.parentNode

3.查子代
    div.childNodes 会包括其它节点(文本、注释...)
    div.children

4.查兄弟姐妹
    div.parentNode.childNodes
    div.parentNode.children

5.查看老大
    div.firstChild

6.查看老幺
    div.lastChild

7.查看上一个哥哥/姐姐
    div.previousSibling 这个会查看到其它节点(注释 | 文本...)
    div.previousElementSibling

8.查看下一个弟弟/妹妹
    div.nextSibling 这个会查看到其它节点(注释 | 文本...)
    div.nextElementSibling
</code></pre>]]></content>
        </item>
        
        <item>
            <title>28 - [JS编程接口]手写DOM库</title>
            <link>http://yaochengjian.com/posts/28/</link>
            <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/28/</guid>
            <description>1.classList用法node.classList.add(&#39;container&#39;) 添加一个类名node.classList.remove(&#39;container&#39;) 删除一个类名node.classList.contains(&#39;container&#39;) 判断是否含有这个类名1.insertBeforenode.insertBefore(newNode,oldNode) 把newNode插入oldNode节点前面3.appendChildparentNode.appendChild(node) 在某个容器插入节点,如果页面已经存在,会抹掉在添加4.removeChildparentNode.removeChild(node) 删除节点github 地址 : dom 封装</description>
            <content type="html"><![CDATA[<pre><code>1.classList用法
    node.classList.add('container') 添加一个类名
    node.classList.remove('container') 删除一个类名
    node.classList.contains('container') 判断是否含有这个类名

1.insertBefore
    node.insertBefore(newNode,oldNode) 把newNode插入oldNode节点前面

3.appendChild
    parentNode.appendChild(node) 在某个容器插入节点,如果页面已经存在,会抹掉在添加

4.removeChild
    parentNode.removeChild(node) 删除节点
</code></pre><p><font color=red>github 地址 : <a href = 'http://yaochengjian.com/dom-1/src/dom.js'>dom 封装</a></font></p>
]]></content>
        </item>
        
        <item>
            <title>29 - [JS编程接口]jQuery中的设计模式</title>
            <link>http://yaochengjian.com/posts/29/</link>
            <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/29/</guid>
            <description>1.链式风格(也叫 JQuery 风格) 1.window.jQuery()是提供的全局函数
2.jQuery(选择器)用于获取对应的元素
3.但是它却不返回这些元素,返回一个对象(jQuery 构造出来的对象)
4.这个对象可以操作对应的元素
&amp;lt;body&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好1&amp;lt;/div&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好2&amp;lt;/div&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好3&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt;window.jQuery = function(seletor){const element = document.querySeletorAll(seletor);return {addClassName(className){for(let i = 0;i &amp;lt; element.length;i++){element[i].classList.add(className);}}return this;}}&amp;lt;/script&amp;gt;2.命名风格 1.如果是通过 jQuery 获取过来的就用 $ 命名开头
2.不是 jQuery 获取过来的就不用
 let div = document.querySelector(&#39;#div&#39;);let $div = jQuery(&#39;#div&#39;); 返回来是一个对象(api)</description>
            <content type="html"><![CDATA[<h3 id="1链式风格也叫-jquery-风格">1.链式风格(也叫 JQuery 风格)</h3>
<p>1.window.jQuery()是提供的全局函数</p>
<p>2.jQuery(选择器)用于获取对应的元素<br>
3.但是它却不返回这些元素,返回一个对象(jQuery 构造出来的对象)<br>
4.这个对象可以操作对应的元素</p>
<pre><code>&lt;body&gt;
    &lt;div id = 'test'&gt;你好1&lt;/div&gt;
    &lt;div id = 'test'&gt;你好2&lt;/div&gt;
    &lt;div id = 'test'&gt;你好3&lt;/div&gt;
&lt;/body&gt;

&lt;script&gt;
    window.jQuery = function(seletor){
        const element = document.querySeletorAll(seletor);

        return {
            addClassName(className){
                for(let i = 0;i &lt; element.length;i++){
                    element[i].classList.add(className);
                }
            }
            return this;
        }
    }
&lt;/script&gt;
</code></pre><h3 id="2命名风格">2.命名风格</h3>
<p>1.如果是通过 jQuery 获取过来的就用 $ 命名开头<br>
2.不是 jQuery 获取过来的就不用</p>
<pre><code>    let div = document.querySelector('#div');
    let $div = jQuery('#div'); 返回来是一个对象(api)
</code></pre>]]></content>
        </item>
        
        <item>
            <title>30 - [JS编程接口]使用jQuery</title>
            <link>http://yaochengjian.com/posts/30/</link>
            <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/30/</guid>
            <description>1.如何使用 jQuery 1.获取网页元素(&amp;hellip;)
1. $(document) 选择整个文档对象2. $(&#39;div&#39;) 获取页面div的元素3. $(&#39;div.myClass&#39;) 选择class为myClass的div元素4. $(&#39;input[name=first]&#39;) 选择name属性等于first的input元素2.筛选
1. $(&#39;div&#39;).has(&#39;p&#39;) 选择div包含p的元素2. $(&#39;div&#39;).not(&#39;.myClass&#39;) 选择class不等于myClss的div元素3. $(&#39;div&#39;).filter(&#39;.myClass&#39;) 选择class等于myClass的div元素4. $(&#39;div&#39;).first(&#39;.myClass&#39;) 选择第1个div元素5. $(&#39;div&#39;).find(&#39;p&#39;).eq(3) div子下第3个p元素3.找后面或者父级或者儿子元素&amp;hellip;
1. $(&#39;div&#39;).next(&#39;p&#39;) 选择div元素后面的第一个p元素2. $(&#39;div&#39;).parent() 选择div元素的父元素3. $(&#39;div&#39;).children() 选择div的所有子元素4. $(&#39;div&#39;).siblings() 选择div的兄弟元素4.jQuery 还提供 .end() 方法,回退到上一个对象上面
 $(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;hello&#39;).end() 退回到选中所有的h3元素的那一步.eq(0) 选中第1个h3元素.html(&#39;World&#39;) 将它内容改为World5.元素的操作 : 取值和赋值
1. $(&#39;h1&#39;).html() html()没有参数,表示取出h1的值2. $(&#39;h1&#39;).html(&#39;hello&#39;) html()有参数hello,表示更改h1里面内容常见取值和赋值函数如下:1. .</description>
            <content type="html"><![CDATA[<h3 id="1如何使用-jquery">1.如何使用 jQuery</h3>
<p>1.获取网页元素(&hellip;)</p>
<pre><code>1. $(document) 选择整个文档对象
2. $('div') 获取页面div的元素
3. $('div.myClass') 选择class为myClass的div元素
4. $('input[name=first]') 选择name属性等于first的input元素
</code></pre><p>2.筛选</p>
<pre><code>1. $('div').has('p') 选择div包含p的元素
2. $('div').not('.myClass') 选择class不等于myClss的div元素
3. $('div').filter('.myClass') 选择class等于myClass的div元素
4. $('div').first('.myClass') 选择第1个div元素
5. $('div').find('p').eq(3) div子下第3个p元素
</code></pre><p>3.找后面或者父级或者儿子元素&hellip;</p>
<pre><code>1. $('div').next('p') 选择div元素后面的第一个p元素
2. $('div').parent() 选择div元素的父元素
3. $('div').children() 选择div的所有子元素
4. $('div').siblings() 选择div的兄弟元素
</code></pre><p>4.jQuery 还提供 .end() 方法,回退到上一个对象上面</p>
<pre><code>    $('div')
        .find('h3')
        .eq(2)
        .html('hello')
        .end() 退回到选中所有的h3元素的那一步
        .eq(0) 选中第1个h3元素
        .html('World') 将它内容改为World
</code></pre><p>5.元素的操作 : 取值和赋值</p>
<pre><code>1. $('h1').html() html()没有参数,表示取出h1的值
2. $('h1').html('hello') html()有参数hello,表示更改h1里面内容

常见取值和赋值函数如下:
1. .html() 取出或设置html内容
2. .text()  取出或设置text内容
3. .attr()  取出或设置某个属性的值
4. .width() 取出或设置某个元素的宽度
5. .height() 取出或设置某个元素的高度
6. .val()   取出某个表单元素的值
</code></pre><p>6.移动元素</p>
<pre><code>1. $('div').insertAfter($('p')) 把div元素移动p元素的后面

2. $('p').insertBefore('div') 把p元素移动到div的前面

3. $('p').appendTo('div') 把p元素插入div内部的后面

4. $('p').prepednTo('div') 把p元素插入div内部的前面
</code></pre><p>7.创建元素、复制、删除</p>
<pre><code>1. .clone() 复制元素
2. .remove() 删除元素,不保留删除元素的事件
3. .detach() 删除元素,保留删除元素的事件
4. .empty() 不会删除元素,删除元素的内容
</code></pre><pre><code>1. $('&lt;p&gt;Hello&lt;/p&gt;')
2. $('&lt;li class = &quot;new&quot;&gt;new list item &lt;/li&gt;')
3. $('ul').append('&lt;li&gt; list item &lt;/li&gt;')
</code></pre><p>7.更详细内容<br>
<font color=red><a href = "http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">jQuery 设计思想 - 阮一峰的网络日志&gt;</a></font></p>
]]></content>
        </item>
        
        <item>
            <title>31 - [项目]前端导航站点</title>
            <link>http://yaochengjian.com/posts/31/</link>
            <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/31/</guid>
            <description>1.onbeforeunload 当窗口即将被关闭,会触发该事件
2.JSON.stringify() 把一个对象变成 JSON 对象形式的字符串
let obj = [1,2,3];JSON.stringify(obj);3.JSON.parse() 把一个 JSON 对象形式字符串变成一个对象
let str = &#39;[0:1,1:2]&#39;;JSON.parse(str);4.localStorage 是本地存储(永久性),解决 cookie 存储空间不足的问题
localStorage.setItem(key,value) 把值以字符串的形式存储在本地 localStorage.getItem(key) 把存储在本地的值取出来
let str = &#39;123456&#39;;localStorage.setItem(&#39;x&#39;,str)localStorage.getItem(&#39;x&#39;);</description>
            <content type="html"><![CDATA[<p>1.onbeforeunload 当窗口即将被关闭,会触发该事件</p>
<p>2.JSON.stringify() 把一个对象变成 JSON 对象形式的字符串</p>
<pre><code>let obj = [1,2,3];
JSON.stringify(obj);
</code></pre><p>3.JSON.parse() 把一个 JSON 对象形式字符串变成一个对象</p>
<pre><code>let str = '[0:1,1:2]';
JSON.parse(str);
</code></pre><p>4.localStorage 是本地存储(永久性),解决 cookie 存储空间不足的问题<br>
localStorage.setItem(key,value) 把值以字符串的形式存储在本地
localStorage.getItem(key) 把存储在本地的值取出来</p>
<pre><code>let str = '123456';
localStorage.setItem('x',str)
localStorage.getItem('x');
</code></pre>]]></content>
        </item>
        
        <item>
            <title>32 - [前后分离]AJAX的原理</title>
            <link>http://yaochengjian.com/posts/32/</link>
            <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/32/</guid>
            <description>1.背景 1.AJAX 是浏览器上的功能
2.浏览器可以发请求,收响应
3.浏览器在 window 上加了一个 XMLHttpRequest 函数
4.用这个构造函数可以构造出一个对象
5.JS 通过它实现发请求,收响应
2.node-dev 代替 node 命令 : npm install -g node-dev
1.方便我们开发
2.修改代码会自动帮我们重启
使用 : node-dev &amp;hellip;&amp;hellip;
3.AJAX  1. let xml = new XMLHttpRequest();2. xml.open(method , url ,async) method请求的方式(&#39;GET&#39;/&#39;POST&#39;), 请求的url地址 , async是true请求则是异步进行,false则是同步进行3. xml.setRequesHeader() 设置请求的头部4. xml.onreadystatechange = function(){} 只要xml.readyState的值变化,就会触发该事件函数5. xml.readyState 属性( 0 ~ 4)0 : 未调用open()方法1 ：open()方法已经被调用2 : send()方法已经被调用3 ：responseText属性已经包含部分数据4 ：已经接收全部数据6.</description>
            <content type="html"><![CDATA[<h3 id="1背景">1.背景</h3>
<p>1.AJAX 是浏览器上的功能<br>
2.浏览器可以发请求,收响应<br>
3.浏览器在 window 上加了一个 XMLHttpRequest 函数<br>
4.用这个构造函数可以构造出一个对象<br>
5.JS 通过它实现发请求,收响应</p>
<h3 id="2node-dev-代替-node">2.node-dev 代替 node</h3>
<p>命令 : npm install -g node-dev</p>
<p>1.方便我们开发<br>
2.修改代码会自动帮我们重启</p>
<p>使用 : node-dev &hellip;&hellip;</p>
<h3 id="3ajax">3.AJAX</h3>
<pre><code>    1. let xml = new XMLHttpRequest();

    2. xml.open(method , url ,async) method请求的方式('GET'/'POST'), 请求的url地址 , async是true请求则是异步进行,false则是同步进行

    3. xml.setRequesHeader() 设置请求的头部

    4. xml.onreadystatechange = function(){} 只要xml.readyState的值变化,就会触发该事件函数

    5. xml.readyState 属性( 0 ~ 4)
       0 : 未调用open()方法
       1 ：open()方法已经被调用
       2 : send()方法已经被调用
       3 ：responseText属性已经包含部分数据
       4 ：已经接收全部数据

    6. xml.status === 200 代表一个成功请求,状态码

    7. xml.responseText 当xml.readyState === 4 &amp;&amp; xml.status === 200是全部后端的返回数据

    8. xml.send() 用于发送http请求,如果是异步请求(请求发送后立即返回),如果是同步(此方法直到响应到达后才返回)
</code></pre><h3 id="4挑战-1加载-css">4.挑战 1(加载 CSS)</h3>
<pre><code>1.加载css
  a : 以前我们用&lt;link rel = 'stylesheet' href=&quot;1.css&quot;/&gt;
  b : 今天请用AJAX加载CSS

2.四个步骤
  a : 创建XMLHttpRequest对象


  b : 调用对象的open方法
      1.xml.open(method,url)
      2.method : 请求方式 url : 请求地址

  c : 监听对象的onload &amp; onerror 事件
      1.专业前端会改用onreadystatechange事件(只要xml.readyState属性发送变化,就会调用相应的处理函数)

      2.在事件处理函数里操作CSS文件内容

  d : 调用对象的send方法(发送请求)

  const xml = new XMLHttpRequest();
        xml.open('GET','1.css');
        xml.onreadystatechange = function(){
            if(xml.readyState === 4 &amp;&amp; xml.status === 200){
                console.log(xml.responseText);
            }
        }
        xml.send();
</code></pre><h3 id="5json-是一门语言跟-htmlcssxmljs-一样是一门独立的语言">5.JSON 是一门语言(跟 HTML、css、XML、JS 一样,是一门独立的语言)</h3>
<p><font color=red><a href="https://www.json.org/json-zh.html">JSON 铁轨图(所有语法)</a></font></p>
<p>1.JSON 不是编程语言(是标记语言),跟 HTML、XML、Markdown 一样,用来展示数据</p>
<p>2.支持的数据类型(6 种)</p>
<pre><code>1. string 只支持双引号,不支持单引号和无引号
2. number 支持科学记数法
3. bool true 和 false
4. null 没有undefined
5. object
6. array

不支持函数,不支持变量
</code></pre><h3 id="5windowjson">5.window.JSON</h3>
<pre><code>JSON.parse
    1.将符合JSON语法的字符串转换成JS对应类型的数据
    2.JSON字符串 =&gt; JS数据
    3.由于JSON只有6种类型,所以转成的数据也只有6种
    4.如果不符合JSON语法,则直接抛出一个Error对象
    5.用 try{}catch(){} 消化

    let json = `{'name':'yaochengjian','age':18}`;
    try{
        JSON.parse(json);
    }catch(error){
        json = {name:'yaochengjian',age:18}
    }
</code></pre><p>JSON.stringify</p>
<pre><code>    1.是 JSON.parse 的逆运算
    2.JS 数据 =&gt; JSON 字符串
    3.由于 JS 的数据类型比 JSON 多,所以不一定能成功
    4.如果失败,就抛出一个 Error 对象
</code></pre>]]></content>
        </item>
        
        <item>
            <title>33 - [前后分离]异步与Promise</title>
            <link>http://yaochengjian.com/posts/33/</link>
            <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/33/</guid>
            <description>1.什么是同步?什么是异步? 1.要理解什么是异步 JavaScript,我们应该从确切理解同步 JavaScript 开始
2.前面学的很多知识基本上都是同步的 &amp;ndash; 运行代码,然后浏览器尽快返回结果,先看一个简单的例子
const btn = document.querySelector(&#39;button&#39;);btn.addEventListener(&#39;click&#39;,()=&amp;gt;{alert(&#39;You clicked me!&#39;);let pElem = document.createElement(&#39;p&#39;);pElem.textContent = &#39;This is a newly-added paragraph.&#39;;document.appendChild(pElem);});这段代码,一行一行的顺序执行:
1.先取得一个 DOM 里面的 button 引用
2.点击按钮的时候,添加一个 click 事件监听
1.alert()消息出现(一直没有点击 alert 消息框,其它事情都阻塞,知道前面操作完成)
2.一但 alert 结束,创建一个 p 元素
3.给它的文本内容赋值
4.最后,把这个段落放进网页
2.Promise 1.它是 ES6 中新增加的类(new Promise),目的是为了管理 JS 中的异步编程的,所以我们也把它称为&#39;Promise&#39;设计模式
1. 三个状态 ：pending(准备:初始化成功,开始执行异步的任务)fulfilled(成功)rejected(失败)new Promise((resolve,reject)=&amp;gt;{=&amp;gt; 这里面一般执行一个异步的任务(new Promise的时候,创建Promise的实例,立即会把当前函数体中的异步操作执行)=&amp;gt; &#39;Promise是同步编程的,它可以管理异步操作&#39;=&amp;gt; resolve : 当异步操作执行成功,我们执行resolve方法=&amp;gt; reject : 当异步操作执行失败,我们执行reject方法setTimeout(()=&amp;gt;{resolve(100);},1000);}).</description>
            <content type="html"><![CDATA[<h3 id="1什么是同步什么是异步">1.什么是同步?什么是异步?</h3>
<p>1.要理解什么是异步 JavaScript,我们应该从确切理解同步 JavaScript 开始</p>
<p>2.前面学的很多知识基本上都是同步的 &ndash; 运行代码,然后浏览器尽快返回结果,先看一个简单的例子</p>
<pre><code>const btn = document.querySelector('button');

      btn.addEventListener('click',()=&gt;{
          alert('You clicked me!');

          let pElem = document.createElement('p');
          pElem.textContent = 'This is a newly-added paragraph.';
          document.appendChild(pElem);
      });
</code></pre><p>这段代码,一行一行的顺序执行:<br>
1.先取得一个 DOM 里面的 button 引用</p>
<p>2.点击按钮的时候,添加一个 click 事件监听<br>
    1.alert()消息出现(一直没有点击 alert 消息框,其它事情都阻塞,知道前面操作完成)<br>
    2.一但 alert 结束,创建一个 p 元素<br>
    3.给它的文本内容赋值<br>
    4.最后,把这个段落放进网页</p>
<h3 id="2promise">2.Promise</h3>
<p>1.它是 ES6 中新增加的类(new Promise),目的是为了管理 JS 中的异步编程的,所以我们也把它称为'Promise'设计模式</p>
<pre><code>1. 三个状态 ：
pending(准备:初始化成功,开始执行异步的任务)
fulfilled(成功)
rejected(失败)

    new Promise((resolve,reject)=&gt;{
        =&gt; 这里面一般执行一个异步的任务(new Promise的时候,创建Promise的实例,立即会
        把当前函数体中的异步操作执行)
        =&gt; 'Promise是同步编程的,它可以管理异步操作'
        =&gt; resolve : 当异步操作执行成功,我们执行resolve方法
        =&gt; reject : 当异步操作执行失败,我们执行reject方法

        setTimeout(()=&gt;{
            resolve(100);
        },1000);
    }).then((res)=&gt;{
        =&gt; 第一个传递函数是resolve
        console.log(res);
    },()=&gt;{
        =&gt; 第二个传递的函数是reject
    });
</code></pre><pre><code>    let val = null;
    let xhr = new XMLHttpRequest();
        xhr.open('get','1.js',true);
        xhr.onreadystatechange = () =&gt;{
            if(xhr.readystate === 4 &amp;&amp; xhr.status === 200){
                val = xhr.responseText;
            }
        }
    xhr.send();
    console.log(val); =&gt;如果使用异步ajax请求,不等ajax彻底完成,就把val输出,此时结果是null
</code></pre><p>Promise 使用案例</p>
<pre><code>let pro = new Promise((resolve, reject) =&gt; {
        let xhr = new XMLHttpRequest();
        xhr.open(&quot;get&quot;, &quot;1.json&quot;, true);
        xhr.onreadystatechange = () =&gt; {
          if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            resolve(xhr.responseText); //=&gt;成功会请求到的值传给第1个then
          }
          if (xhr.status !== 200) {
            reject();
          }
        };
        xhr.send();
      });

      pro.then(
          res =&gt; {
            console.log(res);
            // =&gt; 数据绑定
            return 100; //=&gt;它返回结果传递给第二个then
          },
          () =&gt; {}
        )
        .then(res =&gt; {
          // =&gt; res 就是第一个then return返回的结果
          // =&gt; 当第一个then中的函数执行完,会执行第二个
        })
        .then(() =&gt; {
          // =&gt; 当第二个then中的函数执行完,会执行第三个 等等
        });
</code></pre><p>2.Promise.all([]) 等待所有 promise 成功,如果都成功了,则 all 对应的 promise 也成功,如果有一个失败了,则 all 对应的 promise 失败</p>
<pre><code>    let p1 = new Promise((resolve,reject)=&gt;{
      resolve(&quot;成功了1&quot;);
    });

    let p2 = new Promise((resolve,reject)=&gt;{
      resolve(&quot;成功了2&quot;);
    });

    Promise.all([p1,p2]).then((res)=&gt;{
      console.log(res); // 得到的是一个数组[&quot;成功了1&quot;,&quot;成功了2&quot;]
    });

1.Promse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。
</code></pre><pre><code>    function fn(time){
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          resolve(`${time / 1000}秒醒来`);
        },time);
      });
    }

    let p1 = fn(3000);
    let p2 = fn(2000);

    Promise.all([p1,p2]).then((res)=&gt;{
      console.log(res);  // [&quot;3秒醒来&quot;,&quot;2秒醒来&quot;]
    });
1.需要特别注意的是,Promise.all获得成功结果的数据里面的数据顺序和promise.all接收到的数据顺序是一致的,即p1的结果在前,即便p1的结果获取的比p2要晚。这带来一个绝大的好处:在前端开发请求数据的过程中,偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景,使用Promise.all毫无疑问可以解决这个问题。
</code></pre><p>3.Promise.race 的使用</p>
<pre><code>1.顾名思义,Promise.race就是赛跑意思,意思就是说,Promise.race([p1,p2,p3])里面哪个结果获取的快,就返回那个结果,不管结果本身是成功状态还是失败状态
    function fn(time){
      return new Promise((resolve,reject)=&gt;{
        setTimeout(()=&gt;{
          reslove(time)
        },time);
      });
    }

    let p1 = fn(1000);
    let p2 = fn(500);
    Promise.race([p1,p2]).then((res)=&gt;{
      console.log(res);
    });
</code></pre>]]></content>
        </item>
        
        <item>
            <title>34 - [前后分离]跨域、CORS、JSONP</title>
            <link>http://yaochengjian.com/posts/34/</link>
            <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/34/</guid>
            <description>1.跨域关键知识 1.同源策略(浏览器故意设计的一个功能限制)
2.CORS(突破浏览器限制的一个方法)
3.JSONP(IE 时代的妥协)
2.同源策略 1.源
window.origin 或 location.origin 可以得到当前源
源 = 协议 + 域名 + 端口号
2.如果两个 url 的协议、域名、端口号 完全一致,那么这两个 url 就是同源
3.同源策略定义
1.浏览器规定a. 如果JS运行在源A里,那么就只能获取源A的数据,不能获取源B的数据,即不允许跨域2.举例a. 假设frank.com/index.html 引用了cdn.com/1.jsb. 那么就说 [1.js 运行在源frank.com里]c. 注意这跟cdn.com没有关系,虽然1.js从它那下载d. 所以1.js就只能获取frank.com的数据d. 不能获取1.frank.com 或者 qq.com 的数据3.这是浏览器的功能!浏览器故意要这样设计的4.同源策略的目的是为了保护用户隐私,安全隐私4.其他疑问
1.为什么a.qq.com 访问 qq.com也算跨域、答 : 因为历史上,出现过不同公司共用域名。a.qq.com 和 qq.com 不一定是同一个网站,浏览器谨慎起见,认为这是不同的源2.为什么不同端口也算跨域?答 : 原因同上,一个端口一个公司。任何安全相关的问题都要谨慎对待3.为什么两个网站的ip是一样的,也算跨域?答 : 原因同上,ip可以共用4.为什么可以跨域使用CSS、JS和图片等?答 : 同源策略限制的是数据访问,我们引用CSS、JS和图片的时候,其实并不知道其内容,我们只是在引用3.解决方法一 : CORS (ie6,7,8,9 不支持) 1.</description>
            <content type="html"><![CDATA[<h3 id="1跨域关键知识">1.跨域关键知识</h3>
<p>1.同源策略(浏览器故意设计的一个功能限制)<br>
2.CORS(突破浏览器限制的一个方法)<br>
3.JSONP(IE 时代的妥协)</p>
<h3 id="2同源策略">2.同源策略</h3>
<p>1.源<br>
window.origin 或 location.origin 可以得到当前源<br>
源 = 协议 + 域名 + 端口号</p>
<p>2.如果两个 url 的协议、域名、端口号 完全一致,那么这两个 url 就是同源</p>
<p>3.同源策略定义</p>
<pre><code>1.浏览器规定
    a. 如果JS运行在源A里,那么就只能获取源A的数据,不能获取源B的数据,即不允许跨域

2.举例
    a. 假设frank.com/index.html 引用了cdn.com/1.js
    b. 那么就说 [1.js 运行在源frank.com里]
    c. 注意这跟cdn.com没有关系,虽然1.js从它那下载
    d. 所以1.js就只能获取frank.com的数据
    d. 不能获取1.frank.com 或者 qq.com 的数据

3.这是浏览器的功能!浏览器故意要这样设计的

4.同源策略的目的是为了保护用户隐私,安全隐私
</code></pre><p>4.其他疑问</p>
<pre><code>1.为什么a.qq.com 访问 qq.com也算跨域、
  答 : 因为历史上,出现过不同公司共用域名。a.qq.com 和 qq.com 不一定是同一个网站,浏览器谨慎起见,认为这是不同的源

2.为什么不同端口也算跨域?
  答 : 原因同上,一个端口一个公司。任何安全相关的问题都要谨慎对待

3.为什么两个网站的ip是一样的,也算跨域?
  答 : 原因同上,ip可以共用

4.为什么可以跨域使用CSS、JS和图片等?
  答 : 同源策略限制的是数据访问,我们引用CSS、JS和图片的时候,其实并不知道其内容,我们只是在引用
</code></pre><h3 id="3解决方法一--cors-ie6789-不支持">3.解决方法一 : CORS (ie6,7,8,9 不支持)</h3>
<p>1.问题根源：浏览器默认不同源之间不能互相访问数据,但这两个网站都是自己的</p>
<p>2.解决 : 用 CORS,如果要共享数据,需要提前声明!在你请求的那个网站服务器端设置响应头<br>
   语法: response.setHeader(&ldquo;Access-Control-Allow-Origin&rdquo;,&rdquo; 源 &ldquo;)</p>
<h3 id="4解决-ie6789-跨域问题--jsonp">4.解决 ie6,7,8,9 跨域问题 : JSONP</h3>
<p>1.JSONP 和 JSON 半毛钱关系都没有<br>
2.A 网站是想要获取的数据,在 A 网站服务器端用 js 获取 json 的数据并且写入 window 中的某一个属性里面,B 网站只要访问 A 网站的 js 文件,就能从 window 中属性获取到 A 网站的数据<br>
3.A 网站需要查看 referer 是否 B 网站的域名,是才允许它访问,否则不允许</p>
]]></content>
        </item>
        
        <item>
            <title>35 - [前后分离]Node.js</title>
            <link>http://yaochengjian.com/posts/35/</link>
            <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/35/</guid>
            <description>1.什么是 node.js 1.简单的说 node.js 就是运行在服务端的 JavaScript
2.如果你是一个前端程序员,你不懂得 PHP、Python 等动态编程语言,然后你想创建自己的服务器,那么 node.js 是一个非常好的选择
2.怎么使用 1.require : 我们可以用 require 指令来载入 node.js 模块
require(&amp;ldquo;http&amp;rdquo;);
1. var http = require(&amp;quot;http&amp;quot;); 载入http模块,并将实例化HTTP赋值给变量http2. http对象下面有哪些方法1.http.listen() 接收一个数值参数,指定这个HTTP服务器监听的端口号2.http.createServer(function(request,response){request : 是一个请求对象,里面有请求属性整合1.request.url 获取请求的url/后面的域名(/index)2.request.method 获取请求的方式3.request.on(&amp;quot;data&amp;quot;,(data)=&amp;gt;{}) 当服务端接收到数据时触发4.request.on(&amp;quot;end&amp;quot;,()=&amp;gt;{}); 当服务端接收完数据时触发5.获取cookierequest.headers[&#39;cookie&#39;]response : 是一个响应对象,里面有响应属性整合1.response.statusCode = 200 设置响应状态码2.response.setHeader(&#39;Content-Type&#39;,&#39;text/css;charset=utf-8&#39;) 设置响应头的文件类型3.response.write(&#39;二哈&#39;) 设置响应回去的内容4.response.end() 响应结束,里面可以发送响应的数据5.设置cookieresponse.setHeader(&amp;quot;Set-Cookie&amp;quot;,&amp;quot;name=value&amp;quot;);});3.require(&amp;lsquo;fs&amp;rsquo;); fs 模块用于对系统文件及目录进行读写操作
 var fs = require(&#39;fs&#39;);1.fs.readyFileSync(&amp;quot;文件路径&amp;quot;,&amp;quot;编码格式&amp;quot;) 获取这个文件的内容,是一个字符串2.</description>
            <content type="html"><![CDATA[<h3 id="1什么是-nodejs">1.什么是 node.js</h3>
<p>1.简单的说 node.js 就是运行在服务端的 JavaScript<br>
2.如果你是一个前端程序员,你不懂得 PHP、Python 等动态编程语言,然后你想创建自己的服务器,那么 node.js 是一个非常好的选择</p>
<h3 id="2怎么使用">2.怎么使用</h3>
<p>1.require : 我们可以用 require 指令来载入 node.js 模块</p>
<p>require(&ldquo;http&rdquo;);</p>
<pre><code>1.  var http = require(&quot;http&quot;); 载入http模块,并将实例化HTTP赋值给变量http

2.  http对象下面有哪些方法
    1.http.listen() 接收一个数值参数,指定这个HTTP服务器监听的端口号

    2.http.createServer(function(request,response){
        request : 是一个请求对象,里面有请求属性整合
            1.request.url 获取请求的url/后面的域名(/index)
            2.request.method 获取请求的方式
            3.request.on(&quot;data&quot;,(data)=&gt;{}) 当服务端接收到数据时触发
            4.request.on(&quot;end&quot;,()=&gt;{}); 当服务端接收完数据时触发
            5.获取cookie
                request.headers['cookie']

        response : 是一个响应对象,里面有响应属性整合
            1.response.statusCode = 200 设置响应状态码
            2.response.setHeader('Content-Type','text/css;charset=utf-8') 设置响应头的文件类型
            3.response.write('二哈') 设置响应回去的内容
            4.response.end() 响应结束,里面可以发送响应的数据
            5.设置cookie
                response.setHeader(&quot;Set-Cookie&quot;,&quot;name=value&quot;);
    });
</code></pre><p>3.require(&lsquo;fs&rsquo;); fs 模块用于对系统文件及目录进行读写操作</p>
<pre><code>    var fs = require('fs');
        1.fs.readyFileSync(&quot;文件路径&quot;,&quot;编码格式&quot;) 获取这个文件的内容,是一个字符串
        2.fs.writeFileSync(&quot;文件路径&quot;,&quot;写入内容&quot;) 在这个文件写入对应内容
</code></pre><p>4.require(&lsquo;url&rsquo;); url 模块用于对 url 进行操作</p>
<pre><code>    var url = require('url');
        1.var pathedUrl = url.parse(urlString,bool) 这个方法可以将一个url的字符串解析并返回url对象
            1.pathedUrl.pathname : 域名127.0.0.1/index.html 会返回/index.html

</code></pre><p>5.process.argv 是一个全局对象,是一个数组
process.argv[2]可以用来监听你输入的端口号</p>
<p>6.process.exit(1) 1 是未捕获的致命异常,终止当前进程并返回给定的 code(code 的状态码请查 api)</p>
]]></content>
        </item>
        
        <item>
            <title>37 - [前后分离]Ajax实战:Cookie、Session</title>
            <link>http://yaochengjian.com/posts/36/</link>
            <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/36/</guid>
            <description>1.什么是动态服务器 1.是否请求了数据库
a. 没有请求服务器就是静态服务器
b. 请求了数据库就是动态服务器
2.目标 1 1.实现用户注册功能
a. 用户提交用户名和密码
b. users.json 里就新增一行数据
2.思路
a. 前端写一个 form,让用户填写 name 和 password
b. 前端监听表单事件
c. 前端发送 post 请求,请求位于请求体
d. 后端获取请求体中的 name 和 password
e. 后盾存储数据</description>
            <content type="html"><![CDATA[<h3 id="1什么是动态服务器">1.什么是动态服务器</h3>
<p>1.是否请求了数据库<br>
a. 没有请求服务器就是静态服务器<br>
b. 请求了数据库就是动态服务器</p>
<h3 id="2目标-1">2.目标 1</h3>
<p>1.实现用户注册功能<br>
a. 用户提交用户名和密码<br>
b. users.json 里就新增一行数据</p>
<p>2.思路<br>
a. 前端写一个 form,让用户填写 name 和 password<br>
b. 前端监听表单事件<br>
c. 前端发送 post 请求,请求位于请求体<br>
d. 后端获取请求体中的 name 和 password<br>
e. 后盾存储数据</p>
]]></content>
        </item>
        
        <item>
            <title>38 - MVC</title>
            <link>http://yaochengjian.com/posts/37/</link>
            <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/37/</guid>
            <description>1.MVC 是啥? a.每个模块都可以写成三个对象,分别是 M、V、C
b.M - Model(数据模型)负责操作所有数据
c.V - View(视图)负责所有 UI 界面
d.C - Controller(控制器)负责其他
2.为什么要有设计模式 a.代码重复太多,相同的页面重复写等。MVC 设计模式就是为了解决代码重复，优化代码结构
3.不学 MVC 会有什么情况 a.会出现意大利面条式代码的情况,过于臃肿太长,代码重复率高,页面不整洁等
b.你会变成类似外包程序员,每天重复干着重复的事情,不懂得提升自己,不会封装,不会造轮子
4.用 yarn | 或者 npm 引入 jQuery 1.yranyarn init -v 最好初始化一下yarnyarn add jquery2.npmnpm i jquery然后在js里面 inport $ from &amp;quot;jquery&amp;quot;2.jquery 中的 api
1.trigger(&#39;click&#39;) 自动点击事件$(&amp;quot;li&amp;quot;).trigger(&amp;quot;click&amp;quot;);2.toggleClass(类名,boolean) boolean可以加可不加(true则添加,false则不添加),如果该元素含有此类则删除,没有则添加$(&amp;quot;li&amp;quot;).toggleClass(&#39;active&#39;);3.prependTo() 把一个元素插入到父元素里面的前面$(&#39;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#39;).prependTo($(&amp;quot;#father&amp;quot;));5.简单认识 EventBus 1.什么是 EventBus
EventBus 可以使用监听和触发事件,对所有点实现通信
2.监听和触发两个 API
eventBus.trigger(&#39;click&#39;);eventBus.on(&#39;click&#39;,(){console.log(&amp;quot;我触发了&amp;quot;)})</description>
            <content type="html"><![CDATA[<h3 id="1mvc-是啥">1.MVC 是啥?</h3>
<p>a.每个模块都可以写成三个对象,分别是 M、V、C<br>
b.M - Model(数据模型)负责操作所有数据<br>
c.V - View(视图)负责所有 UI 界面<br>
d.C - Controller(控制器)负责其他</p>
<h3 id="2为什么要有设计模式">2.为什么要有设计模式</h3>
<p>a.代码重复太多,相同的页面重复写等。MVC 设计模式就是为了解决代码重复，优化代码结构</p>
<h3 id="3不学-mvc-会有什么情况">3.不学 MVC 会有什么情况</h3>
<p>a.会出现意大利面条式代码的情况,过于臃肿太长,代码重复率高,页面不整洁等<br>
b.你会变成类似外包程序员,每天重复干着重复的事情,不懂得提升自己,不会封装,不会造轮子</p>
<h3 id="4用-yarn--或者-npm-引入-jquery">4.用 yarn | 或者 npm 引入 jQuery</h3>
<pre><code>1.yran
    yarn init -v 最好初始化一下yarn
    yarn add jquery

2.npm
    npm i jquery

然后在js里面 inport $ from &quot;jquery&quot;
</code></pre><p>2.jquery 中的 api</p>
<pre><code>1.trigger('click') 自动点击事件
    $(&quot;li&quot;).trigger(&quot;click&quot;);

2.toggleClass(类名,boolean) boolean可以加可不加(true则添加,false则不添加),如果该元素含有此类则删除,没有则添加
    $(&quot;li&quot;).toggleClass('active');

3.prependTo() 把一个元素插入到父元素里面的前面
    $('&lt;div&gt;&lt;/div&gt;').prependTo($(&quot;#father&quot;));
</code></pre><h3 id="5简单认识-eventbus">5.简单认识 EventBus</h3>
<p>1.什么是 EventBus<br>
EventBus 可以使用监听和触发事件,对所有点实现通信</p>
<p>2.监听和触发两个 API</p>
<pre><code>eventBus.trigger('click');
eventBus.on('click',(){
    console.log(&quot;我触发了&quot;)
})
</code></pre>]]></content>
        </item>
        
        <item>
            <title>39 - webpack</title>
            <link>http://yaochengjian.com/posts/38/</link>
            <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/38/</guid>
            <description>1.安装 webpack 1.npm info webpack 可以打印出 webpack 的所有信息
2.npm install webpack -g 在全局安装 webpack
3.npm uninstall -g webpack 在全局卸载 webpack
2.webpack 是干嘛用的? 1.转译代码(ES6 转 ES5)
2.构建 build
3.代码压缩
4.代码分析
3.用 webpack 生成 js 1.mkdir webpack-demo (文件名可修改)
2.cd webpack-demo
3.npm init -y
4.npm install webpack webpack-cli &amp;ndash;save-dev(安装依赖,在本地安装)
5.创建一个 src 目录,目录下创建一个 index.js
6../node-modules/.bin/webpack 或者使用 npx webpack 运行本地目录 webpack
4.如何消除警告(WARNING in configuration&amp;hellip;) 1.在目录加上 webpack.config.js 文件(添加以下代码)
module.exports = {mode : &#39;development&#39; development开发模式,production是用户模式(切换模式)}2.</description>
            <content type="html"><![CDATA[<h3 id="1安装-webpack">1.安装 webpack</h3>
<p>1.npm info webpack 可以打印出 webpack 的所有信息<br>
2.npm install webpack -g 在全局安装 webpack<br>
3.npm uninstall -g webpack 在全局卸载 webpack</p>
<h3 id="2webpack-是干嘛用的">2.webpack 是干嘛用的?</h3>
<p>1.转译代码(ES6 转 ES5)<br>
2.构建 build<br>
3.代码压缩<br>
4.代码分析</p>
<h3 id="3font-colorred用-webpack-生成-jsfont">3.<font color=red>用 webpack 生成 js</font></h3>
<p>1.<font color=red>mkdir webpack-demo</font> (文件名可修改)<br>
2.<font color=red>cd webpack-demo</font><br>
3.<font color=red>npm init -y</font><br>
4.<font color=red>npm install webpack webpack-cli &ndash;save-dev</font>(安装依赖,在本地安装)<br>
5.创建一个 src 目录,目录下创建一个 index.js<br>
6.<font color=red>./node-modules/.bin/webpack 或者使用 npx webpack</font> 运行本地目录 webpack</p>
<h3 id="4如何消除警告warning-in-configuration">4.如何消除警告(WARNING in configuration&hellip;)</h3>
<p>1.在目录加上 webpack.config.js 文件(添加以下代码)</p>
<pre><code>module.exports = {
    mode : 'development'  development开发模式,production是用户模式(切换模式)
}
</code></pre><p>2.webpack 配置 entry 和 output</p>
<pre><code>    var path = require('path');
    module.exports = {
        mode: 'development',
        entry: './src/index.js',  转义代码路径
        output: {
            filename: 'index.js'  转义完成后dist目录下的name
        }
    }
</code></pre><p>3.理解 webpack 文件名中的 hash 的用途(http 缓存)<br>
a.HTTP 响应头中的 Cache-Control<br>
b.如果你访问一个网址,会给你访问 html,html 会引入 1.css,2.css,1.js&hellip;.,如果你第二次在访问的时候就会有部分文件会缓存在你的硬盘中
在你缓存有效时间内,在进行访问这个网站缓存下来的文件就不需要在次请求服务器,直接从你的硬盘中获取,能达到超快访问</p>
<pre><code>    var path = require('path');
    module.exports = {
        mode: 'development',
        entry: './src/index.js',
        output: {
            filename: '[name].[contenthash].js' http缓存
        }
    }

    1.每次运行webpack的时候,都会生成新的hash文件,如何解决?(每次运行webpack,把dist目录删掉,在生成即可)
    解决:在package.json中scripts里面添加一句 &quot;build&quot; : &quot;rm -rf dist &amp; webpack&quot;
    2.在命令行重新运行yarn build即可
</code></pre><h3 id="5font-colorred用-webpack-生成-htmlfont">5.<font color=red>用 webpack 生成 HTML</font></h3>
<p>1.<font color=red>yarn add html-webpack-plugin &ndash;dev</font><br>
2.需要在 src 目录下创建 assets 目录,在 assets 目录创建 html 文件<br>
3.在 webpack.config.js 添加如下代码</p>
<pre><code>    var HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
    module.exports = {
        plugins : [new HtmlWebpackPlugin({
            title: '&lt;% htmlWebpackPlugin.options.title %&gt;',  如果想用html的title,需要在这里添加 &lt;% htmlWebpackPlugin.options.title %&gt;
            template: 'src/assets/index.html' 需要在src创建assets目录
        })]
    }
</code></pre><h3 id="6font-colorredwebpack-引入-cssimport-导入font">6.<font color=red>webpack 引入 css(import 导入)</font></h3>
<p>1.<font color=red>yarn add css-loader &ndash;dev</font><br>
2.<font color=red>yarn add style-loader &ndash;dev</font><br>
3.<font color=red>注意：这里 npm 或者 yarn 不能使用淘宝镜像</font>yarn config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a><br>
4.在 webpack.config.js 添加如下代码</p>
<pre><code>    module.exports = {
        module: {
            rules:[
                {
                    test: /\.css$/i,
                    use: [&quot;style-loader&quot;,&quot;css-loader&quot;]
                }
            ]
        }
    }
</code></pre><h3 id="7font-colorred使用-webpack-dev-serverfont">7.<font color=red>使用 webpack-dev-server</font></h3>
<p>1.<font color=red>yarn add webpack-dev-server &ndash;dev</font></p>
<p>2.在 webpack.config.js 添加如下代码</p>
<pre><code>    module.exports = {
        devtool: 'inline-source-map',
        devServer: {
            contentBase: './dist'
        }
    }
</code></pre><p>3.在 package.json 里面 scripts 属性添加如下代码</p>
<pre><code>    &quot;start&quot;: &quot;webpack-dev-server&quot;
</code></pre><p>4.运行 yarn start</p>
<h3 id="8font-colorred如何生成-css-文件font">8.<font color=red>如何生成 css 文件</font></h3>
<p>1.<font color=red>yarn add mini-css-extract-plugin &ndash;dev</font><br>
2.<font color=red>在 webpack.config.js 添加如下代码</font></p>
<pre><code>    const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);
    module.exports = {
        plugins: [
            new MiniCssExtractPlugin({
                filename: '[name].css',
                chunkFilename: '[id].css'
            })
        ],
        module: {
            rules: [
                {
                    test: /\.css$/,
                    use: [
                        {
                            loader: MiniCssExtractPlugin.loader,
                            options: {
                                publicPath: '../',
                                hmr: process.env.NODE_ENV === 'development'
                            },
                        },
                        'css-loader',
                    ]
                }
            ]
        }
    }
</code></pre><h3 id="9font-colorred使用两个-webpackconfigjsfont">9.<font color=red>使用两个 webpack.config.js</font></h3>
<p>1.切换两种模式(用户模式 | 开发模式)</p>
<pre><code>    1.需要拷贝多一份webpack.config.js,如果是用户模式则把css生成文件,开发模式怎用import导入
    2.在webpack.json下scripts属性
        &quot;build&quot; : &quot;rm -rf dist &amp;&amp; webpack --config webpack.config.prod.js&quot;,
        &quot;start&quot; : &quot;webpack-dev-server&quot;
</code></pre><h3 id="10font-colorred用-webpack-引入-scssfont">10.<font color=red>用 webpack 引入 SCSS</font></h3>
<p>1.<font color=red>yarn add sass-loader dart-sass webpack &ndash;save-dev</font><br>
2.在 webpack.config.js 添加如下代码</p>
<pre><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.scss$/i,
        use: [
          'style-loader',
          'css-loader',
          {
            loader: &quot;sass-loader&quot;,
            options: {
            implementation: require('dart-sass')
            }
          }
        ],
      },
    ],
  },
};
</code></pre><h3 id="11font-colorred用-webpack-引入-lessfont">11.<font color=red>用 webpack 引入 less</font></h3>
<p>1.<font color=red>yarn add less-loader &ndash;dev</font><br>
2.<font color=red>需要安装一下 less 环境 yarn add less &ndash;dev</font><br>
3.在 webpack.config.js 添加如下代码</p>
<pre><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        loader: [&quot;style-loader&quot;,&quot;css-loader&quot;,&quot;less-loader&quot;]
      },
    ],
  },
};
</code></pre><h3 id="12font-colorred用-webpack-引入图片font">12<font color=red>用 webpack 引入图片</font></h3>
<p>会自动帮你添加上哈希值<br>
1.<font color=red>yarn add file-loader &ndash;dev</font><br>
2.在 webpack.config.js 添加如下代码</p>
<pre><code>module.exports = {
    module: {
        rules: [
            {
                test: /\.(png|svg|jpg|gif)$/,
                use: ['file-loader'],
            }
        ]
    }
}
</code></pre>]]></content>
        </item>
        
        <item>
            <title>39 - vue全解(起手式0)</title>
            <link>http://yaochengjian.com/posts/39/</link>
            <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/39/</guid>
            <description>1.使用 @vue/cli 搭建项目 a: @vue/cli 是什么?
答: @vue/cli 是 vue 的命令行工具,只要按照官网敲几行命令就可以新建一个基本的 vue 项目框架
b: 安装@vue/cli 与卸载@vue/cli
安装: npm install -g @vue/cli 或 yarn global add @vue/cli
卸载: npm uninstall @vue-cli -g 或 yarn global remove @vue/cli
c: @vue/cli 和 webpack 是什么关系?
答: @vue/cli 里面包含了 webpack,并且配置好了基本的 webpack 打包规则
d: 通过 vue create vue-demo 命令创建一个新项目
e: 进入该目录,yarn serve 开启预览
2.vue.js 完整版和运行时版本区别 完整版 vue.js
a.同时包含编译器和非完整版的版本如果你需要在客户端编译模板(比如传入一个字符串给template选项,或挂载一个元素并以其 DOM 内部的 HTML 作为模板),就将需要加上编译器,即完整版:
 &amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{n}}&amp;lt;/div&amp;gt;vue.</description>
            <content type="html"><![CDATA[<h3 id="1使用-vuecli-搭建项目">1.使用 @vue/cli 搭建项目</h3>
<p><font color=red>a: @vue/cli 是什么?</font><br>
答: @vue/cli 是 vue 的命令行工具,只要按照官网敲几行命令就可以新建一个基本的 vue 项目框架</p>
<p><font color=red>b: 安装@vue/cli 与卸载@vue/cli</font><br>
安装: npm install -g @vue/cli 或 yarn global add @vue/cli<br>
卸载: npm uninstall @vue-cli -g 或 yarn global remove @vue/cli</p>
<p><font color=red>c: @vue/cli 和 webpack 是什么关系?</font><br>
答: @vue/cli 里面包含了 webpack,并且配置好了基本的 webpack 打包规则</p>
<p><font color=red>d: 通过 vue create vue-demo 命令创建一个新项目</font></p>
<p><font color=red>e: 进入该目录,yarn serve 开启预览</font></p>
<h3 id="2vuejs-完整版和运行时版本区别">2.vue.js 完整版和运行时版本区别</h3>
<p><font color=red>完整版 vue.js</font><br>
a.同时包含编译器和非完整版的版本如果你需要在客户端编译模板(比如传入一个字符串给<font color=red>template</font>选项,或挂载一个元素并以其 DOM 内部的 HTML 作为模板),就将需要加上编译器,即完整版:</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        {{n}}
    &lt;/div&gt;

    vue.min.js是压缩版本,里面没有注释
    &lt;script src = &quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        let vm = new Vue({
            el : &quot;#app&quot;,
            data : {
                n : 1
            }
        });
    &lt;/script&gt;

    或

    &lt;script&gt;
        let vm = new Vue({
            el : &quot;#app&quot;,
            template : `&lt;div&gt;{{n}}&lt;/div&gt;`,
            data : {
                n : 3
            }
        });
    &lt;/script&gt;
</code></pre><p><font color=red>运行时版本 vue.runtime.js</font><br>
a.运行时版本在 html 中差值表达式和 template 就无法编译出来(没有包含编译器),只能通过 render 函数来渲染</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;

    &lt;/div&gt;

    &lt;script src = &quot;https://cdn.bootcss.com/vue/2.6.11/vue.runtime.min.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        let vm = new Vue({
            el : &quot;#app&quot;,
            render(h){
                h是createElement缩写
                return h(&quot;div&quot;,this.n);
            },
            data : {
                n : 3
            }
        });
    &lt;/script&gt;
</code></pre><h3 id="3vue-单文件组件">3.Vue 单文件组件</h3>
<p>三个标签 : (template、script、style)</p>
<pre><code>&lt;template&gt;
  &lt;div id=&quot;app&quot; v-bind:class=&quot;red&quot;&gt;
    {{ n }}
    &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
    如果是vue单文件这里data必须是一个函数,并且要return
    data(){
        return {
            n : 1
        }
    },
    methods : {
        add(){
            this.n += 1;
        }
    }
}
&lt;/script&gt;

&lt;style&gt;
.red {
  color: red;
}
&lt;/style&gt;
</code></pre>]]></content>
        </item>
        
        <item>
            <title>40 - vue全解(起手式1)</title>
            <link>http://yaochengjian.com/posts/40/</link>
            <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/40/</guid>
            <description>1.Vue 简介 a: JavaScript 框架
b: 简化 Dom 操作
c: 响应式数据驱动
d: 开发环境版本(类似完整版的 jQuery),生成环境版本(类似 mini 版本的 jQuery)
e: 可以根据官方步骤来创建一个 vue 项目,也可以使用@vue/cli 来搭建
 1.导入开发版本的Vue.js2.创建Vue实例对象,设置el属性和data属性3.使用简洁的模板语法把数据渲染到页面上&amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{message}}&amp;lt;/div&amp;gt;&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;let vue = new Vue({el : &amp;quot;#app&amp;quot;,data : {message : &amp;quot;hello vue!&amp;quot;}});&amp;lt;/script&amp;gt;2.el:挂载点 a: Vue 实例的作用范围是什么呢?
答: Vue 会管理 el 选项命中的元素及内部的后代元素
 &amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{message}}&amp;lt;span&amp;gt;{{message}}&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script src=&amp;quot;https://cdn.</description>
            <content type="html"><![CDATA[<h3 id="1vue-简介">1.Vue 简介</h3>
<p>a: JavaScript 框架<br>
b: 简化 Dom 操作<br>
c: 响应式数据驱动<br>
d: 开发环境版本(类似完整版的 jQuery),生成环境版本(类似 mini 版本的 jQuery)<br>
e: 可以根据官方步骤来创建一个 vue 项目,也可以使用@vue/cli 来搭建</p>
<pre><code>    1.导入开发版本的Vue.js
    2.创建Vue实例对象,设置el属性和data属性
    3.使用简洁的模板语法把数据渲染到页面上

    &lt;div id = &quot;app&quot;&gt;
        {{message}}
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vue = new Vue({
            el : &quot;#app&quot;,
            data : {
                message : &quot;hello vue!&quot;
            }
        });
    &lt;/script&gt;
</code></pre><h3 id="2el挂载点">2.el:挂载点</h3>
<p><font color=red>a: Vue 实例的作用范围是什么呢?</font><br>
答: Vue 会管理 el 选项命中的元素及内部的后代元素</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        {{message}}
        &lt;span&gt;{{message}}&lt;/span&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                message: &quot;欢迎使用vue&quot;
            }
        });
    &lt;/script&gt;
</code></pre><p><font color=red>b: 是否可以使用其它的选择器?</font><br>
答: 可以使用其他的选择器,但是建议使用 ID 选择器</p>
<p><font color=red>c: 是否可以设置其它的 dom 元素呢?</font><br>
答: 可以使用其他的双标签,不能使用 HTML 和 BODY</p>
<h3 id="3font-colorreddata数据对象font">3.<font color=red>data:数据对象</font></h3>
<p>a: Vue 中用到的数据定义在 data 中<br>
b: data 中可以写复杂类型的数据<br>
c: 渲染复杂类型数据时,遵守 js 的语法即可</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        &lt;h1&gt;{{message}}&lt;h1&gt;
        &lt;h2&gt;{{school.name}} {{school.mobile}}&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li&gt;{{campus[0]}}&lt;/li&gt;
            &lt;li&gt;{{campus[1]}}&lt;/li&gt;
            &lt;li&gt;{{campus[2]}}&lt;/li&gt;
            &lt;li&gt;{{campus[3]}}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vm = new Vue({
            el:&quot;#app&quot;,
            data: {
                message: &quot;大家好!我是黑马程序员&quot;,
                school: {
                    name: &quot;黑马程序员&quot;,
                    mobile: &quot;400-618-9090&quot;
                },
                campus: [&quot;北京校区&quot;,&quot;上海校区&quot;,&quot;广州校区&quot;,&quot;深圳校区&quot;]
            }
        });
    &lt;/script&gt;
</code></pre><h3 id="4font-colorred本地应用-vue-指令指的是以-v-开头的一组特殊语法font">4.<font color=red>本地应用-Vue 指令指的是,以 v-开头的一组特殊语法</font></h3>
<p><font color=red>a: v-text 指令作用</font><br>
1.<font color=red>设置标签的内容</font><br>
2.默认写法会替换全部内容,使用<font color=red>差值表达式{{}}</font>可以替换指定内容<br>
3.内部支持写表达式</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        &lt;h1 v-text=&quot;sessage&quot;&gt;&lt;h1&gt;  如果标签里面存在内容会全部被替换掉
        &lt;h1 v-text=&quot;sessage + '!'&quot;&gt;  v-text支持表达式
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vm = new Vue({
            el: &quot;app&quot;,
            data: {
                sessage: &quot;黑马程序员&quot;
            }
        });
    &lt;/script&gt;
</code></pre><p><font color=red>b: v-html 指令作用</font><br>
1.<font color=red>设置元素的 innerHTML</font><br>
2.内容中有<font color=red>html</font>结构会被解析为<font color=red>标签</font><br>
3.<font color=red>v-text</font>指令无论内容是什么,只会解析为<font color=red>文本</font><br>
4.解析文本使用<font color=red>v-text</font>,解析 html 结构使用<font color=red>v-html</font></p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        &lt;h1 v-html=&quot;content&quot;&gt;&lt;/h1&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                content: &quot;&lt;a href='http://itheima.com'&gt;黑马程序猿&lt;/a&gt;&quot;
            }
        });
    &lt;/script&gt;
</code></pre><p><font color=red>c: v-on:绑定事件</font><br>
1.事件名不需要写<font color=red>on</font><br>
2.指令可以简写为<font color=red>@</font><br>
3.绑定的方法定义在 methods 属性中(是对象)<br>
4.方法内部通过<font color=red>this</font>关键字可以访问定义在<font color=red>data 中</font>数据</p>
<pre><code>    &lt;div id = &quot;app&quot;&gt;
        &lt;button v-text=&quot;value&quot; v-on:click=&quot;sayName&quot;&gt;&lt;/button&gt;
        &lt;button v-text=&quot;value&quot; @click=&quot;sayName&quot;&gt;&lt;/button&gt;
    &lt;div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        let vm = new Vue({
            el: &quot;#app&quot;,
            data: {
                value: &quot;黑马程序猿&quot;
            },
            methods: {
                sayName: function(){
                    alert(`my name is ${this.value}`);
                }
            }
        });
    &lt;/script&gt;
</code></pre><p><font color=red>d: v-show 指令作用</font><br>
1.根据真假(boolean)切换元素的显示状态<br>
2.原理是修改元素的 display 实现显示隐藏<br>
3.指令后面可以是<font color=red>表达式或者布尔值</font>,最终会解析为布尔值<br>
4.值为 true 元素显示,值为 false 元素隐藏</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;img
        src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=904699221,385943135&amp;fm=26&amp;gp=0.jpg&quot;
        alt=&quot;&quot;
        v-show=&quot;bool&quot;
      /&gt;
      &lt;button v-text=&quot;display&quot; @click=&quot;showImg&quot;&gt;隐藏&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          display: &quot;隐藏&quot;,
          bool: true,
        },
        methods: {
          showImg: function () {
            this.bool = !this.bool;
            this.display = this.bool ? &quot;隐藏&quot; : &quot;显示&quot;;
          },
        },
      });
</code></pre><p><font color=red>e: v-if 指令</font><br>
1.根据表达式真假切换元素的显示状态<br>
2.本质是通过操作 dom 来切换显示状态<br>
3.表达式为 true,元素存在于 dom 树中,为 false,则从 dom 树移除<br>
4.直接操作 dom 比较耗性能</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;button v-text=&quot;value&quot; v-on:click=&quot;isShow&quot;&gt;&lt;/button&gt;
      &lt;img
        src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=904699221,385943135&amp;fm=26&amp;gp=0.jpg&quot;
        alt=&quot;&quot;
        v-if=&quot;bool&quot;
      /&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          bool: true,
          value: &quot;隐藏&quot;,
        },
        methods: {
          isShow: function () {
            this.bool = !this.bool;
            this.value = this.bool ? &quot;隐藏&quot; : &quot;显示&quot;;
          },
        },
      });
</code></pre><p><font color=red>f: v-bind 指令</font><br>
1.为元素绑定属性<br>
2.完整写法是 v-bind:属性名<br>
3.简写的话可以直接省略 v-bind,只保留 :属性名<br>
4.需要动态的增删 class 建议使用对象方式</p>
<pre><code>    &lt;div id=&quot;app&quot;&gt;
      &lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot; /&gt;
      &lt;br /&gt;
      &lt;img v-bind:src=&quot;url&quot; alt=&quot;&quot; @click=&quot;isShow&quot; :class=&quot;{active:bool}&quot; /&gt;
    &lt;/div&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let vm = new Vue({
        el: &quot;#app&quot;,
        data: {
          url:
            &quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1586370798767&amp;di=41cdc4f1d844e54216dcee9411da0ca3&amp;imgtype=0&amp;src=http%3A%2F%2Fa0.att.hudong.com%2F78%2F52%2F01200000123847134434529793168.jpg&quot;,
          bool: false,
        },
        methods: {
          isShow: function () {
            this.bool = !this.bool;
          },
        },
      });
</code></pre>]]></content>
        </item>
        
        <item>
            <title>50 - </title>
            <link>http://yaochengjian.com/posts/50/</link>
            <pubDate>Sat, 04 Jan 2020 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/50/</guid>
            <description>去重let arr1 = [1,2,3,4,5,1,1,1,2,3,4],arr2.filter(function(item,index,arr){return arr.indexOf(item) === index;}); let arr1 = [1, 2];let arr2 = [1, 2, 3, 4];let arr3 = arr2.filter(function(item, index, array) {return arr1.indexOf(item) &amp;gt;= 0;});2. js 模块化 css.jslet string = &#39;12345&#39;export default string;main.jsimport string from &amp;quot;./css.js&amp;quot;</description>
            <content type="html"><![CDATA[<pre><code>去重
    let arr1 = [1,2,3,4,5,1,1,1,2,3,4],
    arr2.filter(function(item,index,arr){
        return arr.indexOf(item) === index;
    });
</code></pre><pre><code>    let arr1 = [1, 2];
    let arr2 = [1, 2, 3, 4];
    let arr3 = arr2.filter(function(item, index, array) {
        return arr1.indexOf(item) &gt;= 0;
    });
</code></pre><h3 id="2-js-模块化">2. js 模块化</h3>
<pre><code>css.js
    let string = '12345'
    export default string;

main.js
    import string from &quot;./css.js&quot;
</code></pre>]]></content>
        </item>
        
        <item>
            <title>开博大吉</title>
            <link>http://yaochengjian.com/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
            <pubDate>Thu, 26 Dec 2019 21:51:11 +0800</pubDate>
            
            <guid>http://yaochengjian.com/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
            <description>姚成健 </description>
            <content type="html"><![CDATA[<h1 id="姚成健">姚成健</h1>
]]></content>
        </item>
        
        <item>
            <title>1 - 如何使用hugo搭建个人博客</title>
            <link>http://yaochengjian.com/posts/1/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0801</pubDate>
            
            <guid>http://yaochengjian.com/posts/1/</guid>
            <description>1.如何使用 hugo 搭建个人博客 a:进入https://gohugo.io/官网，下载并安装hugo
b:我的电脑-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量-&amp;gt;path-&amp;gt;添加你 hugo 的路径地址
c:hugo version 查看自己的版本,可以看到就代表自己 hugo 安装没问题
d:在 hugo 官网点击 Quick Start 根据步骤一步步实现(下面都是用命令行操作)
1)hugo new site demo(demo 可以更改为自己想要的名字)
2)cd demo 进入 demo
3)git init
4)git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
5)echo &amp;lsquo;theme = &amp;ldquo;ananke&amp;rdquo;&amp;rsquo; &amp;raquo; config.toml
6)hugo new posts/my-first-post.md(my-first-post 可以更改为自己想要的内容)
7)hugo server -D 可以得到一个预览地址
8)打开 config.toml 配置
baseURL = &amp;quot;yaochengjian.com&amp;quot; //更改为自己购买的域名languageCode = &amp;quot;zh-CN&amp;quot;title = &amp;quot;姚成健的博客&amp;quot;theme = &amp;quot;ananke&amp;quot;9)hugo -D
10)上面的完成之后，我们会看到 demo 里面有一个 public 文件名,我们也要在里面 git init 每次只需要提交这个文件里面的内容到 github 仓库即可！！！</description>
            <content type="html"><![CDATA[<h2 id="1如何使用-hugo-搭建个人博客">1.如何使用 hugo 搭建个人博客</h2>
<p>a:进入https://gohugo.io/官网，下载并安装hugo<br>
b:我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;path-&gt;添加你 hugo 的路径地址<br>
c:hugo version 查看自己的版本,可以看到就代表自己 hugo 安装没问题<br>
d:在 hugo 官网点击 Quick Start 根据步骤一步步实现(下面都是用命令行操作)</p>
<p>1)hugo new site demo(demo 可以更改为自己想要的名字)</p>
<p>2)cd demo 进入 demo</p>
<p>3)git init</p>
<p>4)git submodule add <a href="https://github.com/budparr/gohugo-theme-ananke.git">https://github.com/budparr/gohugo-theme-ananke.git</a> themes/ananke</p>
<p>5)echo &lsquo;theme = &ldquo;ananke&rdquo;&rsquo; &raquo; config.toml</p>
<p>6)hugo new posts/my-first-post.md(my-first-post 可以更改为自己想要的内容)</p>
<p>7)hugo server -D 可以得到一个预览地址</p>
<p>8)打开 config.toml 配置</p>
<pre><code>baseURL = &quot;yaochengjian.com&quot;  //更改为自己购买的域名
languageCode = &quot;zh-CN&quot;
title = &quot;姚成健的博客&quot;
theme = &quot;ananke&quot;
</code></pre><p>9)hugo -D</p>
<p>10)上面的完成之后，我们会看到 demo 里面有一个 public 文件名,我们也要在里面 git init 每次只需要提交这个文件里面的内容到 github 仓库即可！！！</p>
<p>11)在 github 上面创建一个仓库,这里我创建仓库名字是(yaochengjian.github.io),进入仓库找到 settings,设置自己购买的域名<br>
<img src="../../images/two.png" alt=""></p>
<p>12)完成购买域名后，我们需要解析 4 条记录<br>
<img src="../../images/one.png" alt=""></p>
<p>13)上面步骤就完成了一个博客搭建啦~需要注意的是,我们需要在 content\posts 里面添加自己的内容,添加完成后都需要 hugo -D,在上传到仓库上面去。</p>
]]></content>
        </item>
        
        <item>
            <title>2 - Node &amp; yarn</title>
            <link>http://yaochengjian.com/posts/2/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0802</pubDate>
            
            <guid>http://yaochengjian.com/posts/2/</guid>
            <description>安装 node.js   安装双数版本
1.node8 node10 node12 是稳定版
2.尽量选择官网安装
3.下载慢就加入 FQ 插件的代理
  安装之后
1.自然就有了 node 命令(因为 PATH)
2.自然就有了 npm 命令
3.自然就有了 npx 命令
  配置 Node.js(因为 node.js 服务器默认在国外，我们需要用淘宝镜像服务器)
1.npm install -global nrm 缩写 npm i -g nrm
npm 是这个命令的开始
install 是载入意思
global 是全局意思
nrm 是一个 npm 源管理器，允许你快速地在 npm 源间切换
2.nrm ls 执行命令查看可选的源
其中带*号的是当前使用的源，如果要切换到 taobao 源，执行命令 nrm use taobao
3.npm config list 查看 nrm 所有配置
  </description>
            <content type="html"><![CDATA[<h2 id="安装-nodejs">安装 node.js</h2>
<ul>
<li>
<p>安装双数版本<br>
1.node8 node10 node12 是稳定版<br>
2.尽量选择官网安装<br>
3.下载慢就加入 FQ 插件的代理</p>
</li>
<li>
<p>安装之后<br>
1.自然就有了 node 命令(因为 PATH)<br>
2.自然就有了 npm 命令<br>
3.自然就有了 npx 命令</p>
</li>
<li>
<p>配置 Node.js(因为 node.js 服务器默认在国外，我们需要用淘宝镜像服务器)<br>
1.npm install -global nrm 缩写 npm i -g nrm<br>
   npm 是这个命令的开始<br>
   install 是载入意思<br>
   global 是全局意思<br>
   nrm 是一个 npm 源管理器，允许你快速地在 npm 源间切换<br>
 <br>
2.nrm ls 执行命令查看可选的源<br>
<img src="../../images/nrmls.png" alt=""><br>
其中带*号的是当前使用的源，如果要切换到 taobao 源，执行命令 nrm use taobao<br>
 
3.npm config list 查看 nrm 所有配置<br>
<img src="../../images/npmconfiglist.png" alt=""></p>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>3 - [Git入门]bash命令行入门</title>
            <link>http://yaochengjian.com/posts/3/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0803</pubDate>
            
            <guid>http://yaochengjian.com/posts/3/</guid>
            <description>1.文件查看操作 1.命令缩写，程序员把动词缩写，就变成了命令
2.查：查看文件或目录
 查看当前目录绝对路径
pwd
 查看当前目录内容
ls
查看指定目录内容
ls 目录名称
 查看文件内容
cat 文件名称(会显示全部内容)
head 文件名称(可以控制想看多少行，从开头开始显示)
tail 文件名称(可以控制想看多少行，从底部开始)
  2.文件的增加删除操作 1.touch 1.txt
确定你路径在哪里，创建一个文件
3.文件(创建 追加 复制 删除)内容 1.echo mmp &amp;gt; 1.txt
向 1.txt 里面追加内容，最新的命令行会覆盖以前追加的信息
2.echo mmp &amp;raquo; 1.txt
向 1.txt 里面追加内容，最新的命令行会叠加以前追加的信息
3.echo -e &amp;ldquo;1/n2&amp;rdquo; &amp;gt; 1.txt
向 1.txt 里面追加两行内容 4.mkdir demo-1
创建一个文件名字为 demo-1 的目录
mkdir -p a/b/c/d
创建多层目录
5.cp 1.txt 2.txt
复制 1.txt 内容为 2.txt
cp -r demo demo1</description>
            <content type="html"><![CDATA[<h2 id="1文件查看操作">1.文件查看操作</h2>
<p>1.命令缩写，程序员把动词缩写，就变成了命令<br>
<img src="../../images/mingl.png" alt="">
 </p>
<p>2.查：查看文件或目录</p>
<ul>
<li>查看当前目录绝对路径<br>
pwd<br>
 </li>
<li>查看当前目录内容<br>
ls<br>
查看指定目录内容<br>
ls 目录名称<br>
<img src="../../images/lsdemo.png" alt="">
 </li>
<li>查看文件内容<br>
cat 文件名称(会显示全部内容)<br>
head 文件名称(可以控制想看多少行，从开头开始显示)<br>
tail 文件名称(可以控制想看多少行，从底部开始)<br>
<img src="../../images/show.png" alt=""></li>
</ul>
<h2 id="2文件的增加删除操作">2.文件的增加删除操作</h2>
<p>1.touch 1.txt<br>
确定你路径在哪里，创建一个文件</p>
<h2 id="3文件创建-追加-复制-删除内容">3.文件(创建 追加 复制 删除)内容</h2>
<p>1.echo mmp &gt; 1.txt<br>
向 1.txt 里面追加内容，最新的命令行会覆盖以前追加的信息</p>
<p>2.echo mmp &raquo; 1.txt<br>
向 1.txt 里面追加内容，最新的命令行会叠加以前追加的信息</p>
<p>3.echo -e &ldquo;1/n2&rdquo; &gt; 1.txt<br>
向 1.txt 里面追加两行内容
<img src="../../images/echo.png" alt=""></p>
<p>4.mkdir demo-1<br>
创建一个文件名字为 demo-1 的目录<br>
<img src="../../images/mkdir.png" alt=""></p>
<p>mkdir -p a/b/c/d<br>
创建多层目录<br>
<img src="../../images/mkdir-1.png" alt=""></p>
<p>5.cp 1.txt 2.txt<br>
复制 1.txt 内容为 2.txt<br>
<img src="../../images/cp.png" alt=""></p>
<p>cp -r demo demo1<br>
复制 demo 目录内容为 demo1<br>
<img src="../../images/cp1.png" alt=""></p>
<h2 id="4font移动文件目录--重命名文件目录-都是同一个命令">4.</font>移动文件/目录 &amp;&amp; 重命名文件/目录 都是同一个命令</h2>
<p>1.mv 1.txt demo<br>
把 1.txt 移动到 demo 目录上面<br>
<img src="../../images/mv.png" alt=""></p>
<h2 id="5font补充">5.</font>补充</h2>
<p>code .<br>
用编辑器打开当前目录( . 代表当前目录)</p>
]]></content>
        </item>
        
        <item>
            <title>4 - [Git入门]本地仓库</title>
            <link>http://yaochengjian.com/posts/4/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0804</pubDate>
            
            <guid>http://yaochengjian.com/posts/4/</guid>
            <description>1.git 就是开启 GitHub 的钥匙 2.git 的 6 行配置(必须存在，否则 git 无法使用) git config &amp;ndash;global user.name 你的英文名(yaochengjian)
git config &amp;ndash;global user.email 你的邮箱(915248459@qq.com)
git config &amp;ndash;global push.default simple
git config &amp;ndash;global core.quotepath false
git config &amp;ndash;global core.eaitor &amp;ldquo;code &amp;ndash;wait&amp;rdquo;
git config &amp;ndash;global core.autocrlf input
注意：上面的英文名和邮箱跟 Github 没有关系，可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致
3.git 可以让你的代码有版本(可以随时回退到某个版本，当然 git 还有其它更强大的功能) 1.git init
会创建.git 目录/仓库，用来容纳你的代码快照
2.git add 路径
选择哪些变动是需要提交的，相对路径/绝对路径
3..gitignore
描述哪些变动是不需要提交的
4.git status
通过这个命令可以查看哪些文件需要提交的
5.git commit -m 字符串
把上面提交的代码复制一份到.git 目录里面
git commit -v</description>
            <content type="html"><![CDATA[<h2 id="1git-就是开启-github-的钥匙">1.git 就是开启 GitHub 的钥匙</h2>
<h2 id="2git-的-6-行配置必须存在否则-git-无法使用">2.git 的 6 行配置(必须存在，否则 git 无法使用)</h2>
<p>git config &ndash;global user.name 你的英文名(yaochengjian)<br>
git config &ndash;global user.email 你的邮箱(<a href="mailto:915248459@qq.com">915248459@qq.com</a>)<br>
git config &ndash;global push.default simple<br>
git config &ndash;global core.quotepath false<br>
git config &ndash;global core.eaitor &ldquo;code &ndash;wait&rdquo;<br>
git config &ndash;global core.autocrlf input<br>
注意：上面的英文名和邮箱跟 Github 没有关系，可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致</p>
<h2 id="3git-可以让你的代码有版本可以随时回退到某个版本当然-git-还有其它更强大的功能">3.git 可以让你的代码有版本(可以随时回退到某个版本，当然 git 还有其它更强大的功能)</h2>
<p>1.git init<br>
会创建.git 目录/仓库，用来容纳你的代码快照<br>
<img src="../../images/gitinit.png" alt=""></p>
<p>2.git add 路径<br>
选择哪些变动是需要提交的，相对路径/绝对路径<br>
<img src="../../images/gitadd.png" alt=""></p>
<p>3..gitignore<br>
描述哪些变动是不需要提交的<br>
<img src="../../images/gitignore.png" alt=""></p>
<p>4.git status<br>
通过这个命令可以查看哪些文件需要提交的<br>
<img src="../../images/status.png" alt=""></p>
<p>5.git commit -m 字符串<br>
把上面提交的代码复制一份到.git 目录里面<br>
<img src="../../images/commit.png" alt=""><br>
git commit -v<br>
个人更喜欢&ndash;verbose 选项，因为它能帮我回顾刚刚改了什么东西，而且会迫使我把提交理由写得更详细一些</p>
<p>6.git log<br>
可以显示所有提交过的版本信息<br>
<img src="../../images/gitlog.png" alt=""></p>
<p>7.git reflog<br>
可以查看所有分支操作记录以及提交过的版本<br>
   git reset &ndash;hard 0aa5218(版本号)<br>
版本回退，可以选择之前提交过的版本<br>
<img src="../../images/gitreflog.png" alt=""></p>
<p>8.查看分支 创建分支 切换分支 合并分支 删除分支<br>
git branck 基于当前 commit 创建一个新的分支，也可以查看分支<br>
git checkout 用户切换分支<br>
git merge master 进入保留分支，运行 git merge master<br>
git branch -d x 合并完成后删除无用分支<br>
<img src="../../images/branch.png" alt=""><br>
<img src="../../images/branch1.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>5 - [Git入门]git远程仓库GitHub</title>
            <link>http://yaochengjian.com/posts/5/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0805</pubDate>
            
            <guid>http://yaochengjian.com/posts/5/</guid>
            <description>操控远程仓库 GitHub 1.如何生成 ssh key(需要在 github 上面填写公钥)
a. 运行 ssh-keygen -t rsa -b 4096 -C 你的邮箱
b. 一直回车，直至到没有提示
2.如何测试配对成功
a. ssh -T git@github.com
b. 如果问你 yes/no，请回答 yes 并回车
3.上传代码
a. 新建 GitHub Repo，赋值其 ssh 地址
b. git remote add origin git@xxxxxxxx
c. 在本地仓库添加远程仓库地址
d. origin 是远程仓库的默认名字，可以换，建议不要换
e. 不要使用https://地址，因为每次都需要密码
f. git push -u origin master 推送本地 master 分支到远程 origin 的 master 分支
4.如何下载代码
a. gitclone git@xxxx[目标路径] b. 如果是不同机器，要写上传新的 ssh key[一机一 key]</description>
            <content type="html"><![CDATA[<h2 id="操控远程仓库-github">操控远程仓库 GitHub</h2>
<p>1.如何生成 ssh key(需要在 github 上面填写公钥)<br>
   a. 运行 ssh-keygen -t rsa -b 4096 -C 你的邮箱<br>
   b. 一直回车，直至到没有提示<br>
<img src="../../images/sshkey.png" alt=""></p>
<p>2.如何测试配对成功<br>
   a. ssh -T <a href="mailto:git@github.com">git@github.com</a><br>
   b. 如果问你 yes/no，请回答 yes 并回车</p>
<p>3.上传代码<br>
   a. 新建 GitHub Repo，赋值其 ssh 地址<br>
   b. git remote add origin git@xxxxxxxx<br>
   c. 在本地仓库添加远程仓库地址<br>
   d. origin 是远程仓库的默认名字，可以换，建议不要换<br>
   e. 不要使用https://地址，因为每次都需要密码<br>
   f. git push -u origin master 推送本地 master 分支到远程 origin 的 master 分支<br>
<img src="../../images/gitpush.png" alt=""></p>
<p>4.如何下载代码<br>
   a. gitclone git@xxxx[目标路径]
   b. 如果是不同机器，要写上传新的 ssh key[一机一 key]<br>
<img src="../../images/clone.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>6 - HTML入门笔记1</title>
            <link>http://yaochengjian.com/posts/6/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0806</pubDate>
            
            <guid>http://yaochengjian.com/posts/6/</guid>
            <description>1.HTML 是谁发明的 蒂姆·伯纳斯-李是第一个使用超文本来分享资讯，及于 1990 发明了首个网页浏览器&amp;ndash;WorldWideWeb 的人
2.HTML 起手式应该写什么 &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0&amp;quot;/&amp;gt;&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie-edge&amp;quot;/&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;3.章节标签(表示文章/书的层级) -标题 h1~h6
-章节 section
-文章 article
-段落 p
-头部 header
-脚部 footer
-主要内容 main
-旁支分支 aside
-划分 div
4.全局属性(所有标签都有的属性) -class 类选择器
-contenteditable 页面实时编辑
-hidden 隐藏
-id 选择器 ID
-style 样式，行内样式
-tabindex 用来控制键盘 tab 顺序，从序号 1 开始，0 代表最后一个
-title 标题
5.内容标签 -ol+li 有序列表 ol 子集不能含有任何子元素或者中文</description>
            <content type="html"><![CDATA[<h2 id="1html-是谁发明的">1.HTML 是谁发明的</h2>
<p>蒂姆·伯纳斯-李是第一个使用超文本来分享资讯，及于 1990 发明了首个网页浏览器&ndash;WorldWideWeb 的人</p>
<h2 id="2html-起手式应该写什么">2.HTML 起手式应该写什么</h2>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;/&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie-edge&quot;/&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="3章节标签表示文章书的层级">3.章节标签(表示文章/书的层级)</h2>
<p>-标题 h1~h6<br>
-章节 section<br>
-文章 article<br>
-段落 p<br>
-头部 header<br>
-脚部 footer<br>
-主要内容 main<br>
-旁支分支 aside<br>
-划分 div</p>
<h2 id="4全局属性所有标签都有的属性">4.全局属性(所有标签都有的属性)</h2>
<p>-class 类选择器<br>
-contenteditable 页面实时编辑<br>
-hidden 隐藏<br>
-id 选择器 ID<br>
-style 样式，行内样式<br>
-tabindex 用来控制键盘 tab 顺序，从序号 1 开始，0 代表最后一个<br>
-title 标题</p>
<h2 id="5内容标签">5.内容标签</h2>
<p>-ol+li 有序列表 ol 子集不能含有任何子元素或者中文<br>
-ul+li 无序列表 ul 子集不能含有任何子元素或者中文<br>
-dl+dt+dd 描述列表，dt 是描述的对象，dd 描述对象的内容<br>
-pre 被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体<br>
-hr 水平分割线<br>
-br 换行<br>
-a 跳转链接<br>
-em 强调标签，有斜体的默认样式<br>
-strong 强调加粗字体标签<br>
-code 标签内的文本将用等宽字体显示出来<br>
-quote 是引用的意思，没有任何效果，是一个内联样式<br>
-blockquote 也是引用意思，是一个块级样式引用</p>
<h2 id="6vscode-插件推荐prettier-更好地格式化工具代码格式乱可以自动格式化">6.VScode 插件推荐(Prettier 更好地格式化工具，代码格式乱可以自动格式化)</h2>
<p>a:下载 Prettier<br>
b:文件-&gt;首选项-&gt;设置-&gt;搜索 auto save-&gt;Files Auto Save 选择 onFocusChange<br>
c:文件-&gt;首选项-&gt;设置-&gt;搜索 format on save-&gt;Editor:Format On Save 勾上</p>
<h2 id="7推荐几个比较好用的线上代码工具">7.推荐几个比较好用的线上代码工具</h2>
<p>a:代码沙盒 codesandbox.io<br>
b:js.jirengu.com</p>
]]></content>
        </item>
        
        <item>
            <title>7 - [HTML全解]HTML重难点</title>
            <link>http://yaochengjian.com/posts/7/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0807</pubDate>
            
            <guid>http://yaochengjian.com/posts/7/</guid>
            <description>1.像用户一样利用网址来打开网页 1)yarn global add parcel
2)parcel 1.a.html(文件名字)
1)yarn global add http-server
2)http-server
2.a 标签(属性) (1)href 取值
a:网址[https://google.com、http://google.com、//google.com]
b:路径[/a/b/c 或者 a/b/c]
c:伪协议[javascript:;代码、mailto:邮箱、tel:手机号]
d:id[href=&amp;rdquo;#xxx&amp;quot;定位锚文本为#xxx 标签]
网址&amp;lt;a href = &amp;quot;https://google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;https://google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;//google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;路径&amp;lt;a href = &amp;quot;/a/b/c&amp;quot;&amp;gt;相对路径&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;a/b/c&amp;quot;&amp;gt;绝对路径&amp;lt;/a&amp;gt;伪协议&amp;lt;a href = &amp;quot;javascript:;&amp;quot;&amp;gt;点击会跳转不了&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;mailto:915248459@qq.com&amp;quot;&amp;gt;邮箱&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;tel:13580466113&amp;quot;&amp;gt;电话&amp;lt;/a&amp;gt;锚文本定位&amp;lt;p id = &amp;quot;xxx&amp;quot;&amp;gt;1&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;3&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;4&amp;lt;/p&amp;gt;&amp;lt;a href = &amp;quot;#xxx&amp;quot;&amp;gt;会定位到id为#xxx上面去&amp;lt;/a&amp;gt;(2)target 属性值</description>
            <content type="html"><![CDATA[<h2 id="1像用户一样利用网址来打开网页">1.像用户一样利用网址来打开网页</h2>
<p>1)yarn global add parcel<br>
2)parcel 1.a.html(文件名字)</p>
<p>1)yarn global add http-server<br>
2)http-server</p>
<h2 id="2a-标签属性">2.a 标签(属性)</h2>
<p>(1)href 取值<br>
a:网址[https://google.com、http://google.com、//google.com]<br>
b:路径[/a/b/c 或者 a/b/c]<br>
c:伪协议[javascript:;代码、mailto:邮箱、tel:手机号]<br>
d:id[href=&rdquo;#xxx&quot;定位锚文本为#xxx 标签]</p>
<pre><code>网址
&lt;a href = &quot;https://google.com&quot;&gt;谷歌&lt;/a&gt;
&lt;a href = &quot;https://google.com&quot;&gt;谷歌&lt;/a&gt;
&lt;a href = &quot;//google.com&quot;&gt;谷歌&lt;/a&gt;
路径
&lt;a href = &quot;/a/b/c&quot;&gt;相对路径&lt;/a&gt;
&lt;a href = &quot;a/b/c&quot;&gt;绝对路径&lt;/a&gt;
伪协议
&lt;a href = &quot;javascript:;&quot;&gt;点击会跳转不了&lt;/a&gt;
&lt;a href = &quot;mailto:915248459@qq.com&quot;&gt;邮箱&lt;/a&gt;
&lt;a href = &quot;tel:13580466113&quot;&gt;电话&lt;/a&gt;
</code></pre><pre><code>锚文本定位
&lt;p id = &quot;xxx&quot;&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;a href = &quot;#xxx&quot;&gt;会定位到id为#xxx上面去&lt;/a&gt;
</code></pre><p>(2)target 属性值<br>
a:_balck 浏览器总在一个新窗口打开<br>
b:_top 浏览器在当前窗口最顶层打开
c:parent 浏览器在超链接父元素(iframe)上面打开<br>
d:_self 浏览器在当前窗口打开</p>
<p>(3)作用<br>
a:跳转外部页面<br>
b:跳转内部锚点<br>
c:跳转到邮箱或电话等</p>
<h2 id="3table">3.table</h2>
<p>(1)相关标签<br>
a:table
b:thead<br>
c:tbody<br>
d:tfoot<br>
e:tr<br>
f:td<br>
g:th</p>
<pre><code>&lt;table&gt;
    &lt;thead&gt;
        &lt;th&gt;表头1&lt;/th&gt;
        &lt;th&gt;表头2&lt;/th&gt;
        &lt;th&gt;表头3&lt;/th&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;2&lt;/td&gt;
            &lt;td&gt;3&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;1&lt;/td&gt;
            &lt;td&gt;2&lt;/td&gt;
            &lt;td&gt;3&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
    &lt;tfoot&gt;
        &lt;tr&gt;
            &lt;td&gt;表格底部1&lt;/td&gt;
            &lt;td&gt;表格底部2&lt;/td&gt;
            &lt;td&gt;表格底部3&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
&lt;/table&gt;
</code></pre><p>(2)相关的样式<br>
a:table-layout<br>
b:border-collapse 控制 table 表格是否合并，默认是不合并<br>
c:border-spacing 控制表格和表格之间的距离</p>
<pre><code>table{
    border-collapse:collapse;
    border-spacing:10px;
}
</code></pre><h2 id="4img-标签">4.img 标签</h2>
<p>(1)作用<br>
a:发出 get 请求，展示一张图片</p>
<p>(2)属性<br>
a:alt 图片请求错误时候，会显示 alt 的文字<br>
b:height 只写高度值，宽度会自适应<br>
c:width 只写宽度值，高度会自适应<br>
d:src 图片地址</p>
<p>(3)js 事件<br>
a:onload 图片加载成功执行的事件<br>
b:onerror 图片加载失败执行的事件</p>
<pre><code>&lt;img src=&quot;1.jpg&quot; id=&quot;img&quot;&gt;&lt;/img&gt;
&lt;script&gt;
    var img = document.getElementById('img');
    img.onload = function(){
        alert('这代表图片加载出来了');
    }
    img.onerror = function(){
        alert('图片加载出错了')
    }
&lt;/script&gt;
</code></pre><p>(4)响应式<br>
a:max-width:100% 加上最大宽度为 100%，那这个图片就是响应式了，就不会固定大小</p>
<h2 id="5from-标签必须要含有一个属性-typesubmit这个表单才能被提交">5.from 标签(必须要含有一个属性 type=&quot;submit&rdquo;，这个表单才能被提交)</h2>
<p>(1)作用<br>
a:发 get 或 post 请求，然后刷新页面</p>
<p>(2)属性<br>
a:action 后台提交地址<br>
b:autocomplete 输入框提示信息，输入框必须要有 name 属性<br>
c:method 提交的方式，有 get 和 post 两个值<br>
d:target 告诉浏览器我要提交到哪个页面，和 a 标签 target 用法雷同</p>
<p>(3)事件<br>
a:onsubmit 在表单确认提交发生的事件</p>
<pre><code>&lt;from action=&quot;1.php&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot;&gt;
&lt;/from&gt;
&lt;script&gt;
    var submit = document.getElementById('submit');
    submit.onsubmit=function(){
        alert('点击提交按钮触发的事件');
    }
&lt;/script&gt;
</code></pre><h2 id="6form-标签的-input-标签">6.form 标签的 input 标签</h2>
<p>a:文本输入框</p>
<pre><code>&lt;input type = &quot;text&quot;&gt;&lt;/input&gt;
</code></pre><p>b:颜色输入框</p>
<pre><code>&lt;input type = &quot;color&quot;&gt;&lt;/input&gt;
</code></pre><p>c:单项选择框(name 必须要一致才能实现单项)</p>
<pre><code>&lt;input type=&quot;audio&quot; name=&quot;sex&quot;&gt;男&lt;/input&gt;
&lt;input type=&quot;audio&quot; name=&quot;sex&quot;&gt;女&lt;/input&gt;
</code></pre><p>d:密码框</p>
<pre><code>&lt;input type=&quot;password&quot;&gt;&lt;/input&gt;
</code></pre><p>e:多选框</p>
<pre><code>&lt;input type=&quot;checkbox&quot; name=&quot;hobies&quot;&gt;LOL&lt;/input&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;hobies&quot;&gt;王者荣耀&lt;/input&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;hobies&quot;&gt;绝地求生&lt;/input&gt;
</code></pre><p>f:上传文件</p>
<pre><code>&lt;!--只能提交单个文件--&gt;
&lt;input type=&quot;file&quot;&gt;
&lt;!--加了multiple能提交多个文件&gt;
&lt;input type=&quot;file&quot; multiple&gt;
</code></pre><p>g:文本输入控件(resize:none 用户无法调整元素属性)</p>
<pre><code>&lt;textarea style=&quot;resize:none&quot;&gt;&lt;/textarea&gt;
</code></pre><p>h:select 下拉选择</p>
<pre><code>&lt;select&gt;
    &lt;option&gt;-请选择-&lt;/option&gt;
    &lt;option&gt;星期一&lt;/option&gt;
    &lt;option&gt;星期二&lt;/option&gt;
&lt;/select&gt;
</code></pre><h2 id="7js-事件">7.js 事件</h2>
<p>a:onchange 改变时候触发这个事件<br>
b:onfocus 光标在身上触发这个事件<br>
c:onblur 失去光标触发这个事件</p>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;text&quot;&gt;&lt;/input&gt;
&lt;script&gt;
    var text = document.getElementById('text');
    text.onchange = function(){
        console.log('文本框内容发生了改变，触发了这个事件');
    }
    text.onfocus = function(){
        console.log('光标聚集执行的事件');
    }
    text.onblur = function(){
        console.log('失去光标触发这个事件');
    }
&lt;/script&gt;
</code></pre>]]></content>
        </item>
        
        <item>
            <title>8 - [css全解]css基础</title>
            <link>http://yaochengjian.com/posts/8/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0808</pubDate>
            
            <guid>http://yaochengjian.com/posts/8/</guid>
            <description>1. 我怎么知道哪些浏览器兼容哪些特性呢？ a：几十种浏览器全部跑一遍
b：使用 caniuse.com
2.语法超级简单 语法 1
选择器{
属性名:属性值
/*这是一个注释*/
}
p{color:blue;background:red;}!注意事项 a：所有符号都是英文符号，如果写错了，浏览器会警告
b：区分大小写，a 和 A 是不同东西
c：最后一个分号可以省略，但建议不要省略
d：任何地方写错了，都不会报错，浏览器会直接忽略
语法 2：@语法
@charset &amp;ldquo;utf-8&amp;rdquo;;
@import url(2.css);
@media(min-width:100px) and (max-width:200px){ }
!注意事项 a：@charset 必须放在第一行
b：前面两个@语法必须以分号;结尾
c：charset 是字符集的意思，但是 utf-8 是字符编码
3.border 调试法 a：怀疑某个元素有问题就给这个元素加 border
b：border 没出现?说明选择器错了或者语法错了
c：bug 解决了才可以把 border 删掉
4.文档流 -流动方向 a：inline 元素从左到右，到达最右边才会换行
b：block 元素从上到下，每一个都另起一行
c：inline-block 也是从左到右，但是到达最后的时候不会把自己分为两块
-宽度
a：inline 宽度靠内部内容宽度撑开，不能用 width 指定
b：blcok 默认自动计算宽度，可用 width 指定
c：inline-block 结合前两者特点，可用 width</description>
            <content type="html"><![CDATA[<h3 id="1-我怎么知道哪些浏览器兼容哪些特性呢">1. 我怎么知道哪些浏览器兼容哪些特性呢？</h3>
<p>a：几十种浏览器全部跑一遍<br>
b：使用 caniuse.com</p>
<h3 id="2语法超级简单">2.语法超级简单</h3>
<p>语法 1<br>
<font color=red>选择器</font>{<br>
    <font color=blue>属性名</font>:<font color=green>属性值</font><br>
    /*这是一个注释*/<br>
}</p>
<pre><code>p{
    color:blue;
    background:red;
}
</code></pre><p><strong>!注意事项</strong>
a：所有符号都是英文符号，如果写错了，浏览器会警告<br>
b：区分大小写，a 和 A 是不同东西<br>
c：最后一个分号可以省略，但建议不要省略<br>
d：任何地方写错了，都不会报错，浏览器会直接忽略</p>
<p>语法 2：@语法<br>
@charset &ldquo;utf-8&rdquo;;<br>
@import url(2.css);<br>
@media(min-width:100px) and (max-width:200px){        }</p>
<p><strong>!注意事项</strong>
a：@charset 必须放在第一行<br>
b：前面两个@语法必须以分号;结尾<br>
c：charset 是字符集的意思，但是 utf-8 是字符编码</p>
<h3 id="3border-调试法">3.border 调试法</h3>
<p>a：怀疑某个元素有问题就给这个元素加 border<br>
b：border 没出现?说明选择器错了或者语法错了<br>
c：bug 解决了才可以把 border 删掉</p>
<h3 id="4文档流">4.文档流</h3>
<p><strong>-流动方向</strong>
a：inline 元素从左到右，到达最右边才会换行<br>
b：block 元素从上到下，每一个都另起一行<br>
c：inline-block 也是从左到右，但是到达最后的时候不会把自己分为两块<br>
<img src="../../images/display.png" alt=""></p>
<p><strong>-宽度</strong><br>
a：inline 宽度靠内部内容宽度撑开，不能用 width 指定<br>
b：blcok 默认自动计算宽度，可用 width
指定<br>
c：inline-block 结合前两者特点，可用 width</p>
<p><strong>-高度</strong><br>
a：inline 高度由 line-height 间接确定，跟 height 无关，跟 padding 无关<br>
b：block 高度由内部文档流元素决定(脱离文档流元素除外)，可以设 height<br>
c：inline-block 跟 block 类似，可以设置 height</p>
<h3 id="5overflow-溢出当内容大于容器">5.overflow 溢出(当内容大于容器)</h3>
<p>a：等内容的宽度或高度大于容器，会溢出<br>
b：可用 overflow 来设置是否显示滚动条<br>
c：auto 是灵活设置<br>
d：scroll 是永远显示<br>
e：hidden 是直接隐藏溢出部分<br>
f：visible 是直接显示溢出部分
g：overflow 可以分为 overflow-x 和 overflow-y</p>
<p>① 块级元素如果没有设置 width，那么它默认的宽度就是 auto<br>
② 永远不要写 width=100%，非常特殊的可以写</p>
<h3 id="6脱离文档流">6.脱离文档流</h3>
<p><strong>-哪些元素脱离文档流</strong>
a：float<br>
b：position:absolute / fixed</p>
<p><strong>-怎么让元素不脱离文档流</strong><br>
a：不要使用上面属性就不会脱离文档流了</p>
<p>① 只要脱离了文档流，就算你清除了，永远都是脱离的了</p>
<h3 id="7盒模型">7.盒模型</h3>
<p>① 如果面试官问你！请说一下 css 盒模型 标准回答：css 盒模型分两种<br>
content-box 宽度或高度 只包含 content<br>
border-box 宽度或高度 由 border+padding+content(尽量使用 border-box)<br>
<img src="../../images/border-sizing.png" alt=""></p>
<p>②margin 合并(只会上下合并，左右不会合并)<br>
哪些情况会合并<br>
a：父子 margin 合并<br>
b：兄弟 margin 合并</p>
<p>如何阻止合并(不需要知道为什么)
a：父子合并用 padding 或 border 挡住<br>
b：父子合并用 overflow:hidden 挡住<br>
c：父子合并用 display:flex<br>
d：兄弟合并是符合预期的<br>
e：兄弟合并可以用 inline-block 消除<br>
f：总之要一条条死记</p>
<p>③ 基本单位<br>
长度单位<br>
a：px 像素<br>
b：em 相当于自身 font-size 的倍数<br>
c: 百分数<br>
d: 整数</p>
<p>颜色<br>
a：十六进制#FF6600 或者 #F60<br>
b: RGBA 颜色 rgb(255,0,0) 或者 rgba(255,0,0,1) - a 是透明意思(取值 0~1)</p>
<pre><code>  div{
      width:100px;
      height:100px;
      background:#FF6600;
      background:rgb(255,0,0);
      background:rgba(255,0,0,0.5);
  }
</code></pre>]]></content>
        </item>
        
        <item>
            <title>9 - [css全解]布局</title>
            <link>http://yaochengjian.com/posts/9/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0809</pubDate>
            
            <guid>http://yaochengjian.com/posts/9/</guid>
            <description>1.布局分类 两种
a: 固定宽度布局，一般宽度为 960 、 1000 、 1024px
b: 不固定宽度布局，主要靠文档流的原理来布局
2.还记得吗? a: 文档流本来就是自适应的，不需要加额外的样式
&amp;lt;style&amp;gt;span{border:1px solid red;}&amp;lt;/style&amp;gt;//它本来就会根据你页面的宽度大小来自适应&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;3.第三种布局 a: 响应式布局
b: 意思就是 pc 上固定宽度，手机上不固定宽度
c: 也就是一种混合布局
4.布局的两种思路 ① 从大到小
先定下大局
然后完善每个部分的小布局
② 从小到大
先完成小布局
然后组合成大布局
③ 两种均可
新人推荐用第二种，因为小的简单
老手一般用第一种，因为熟练有大局观
4.用什么 css 布局 5.float 布局 a: 步骤
-子元素上加 float:left/right 和 width
-在父元素上加.clearfix(必须要加上)
实践 不同布局
-用 float 做两栏布局(如顶部条)
-用 float 做三栏布局(内容区)</description>
            <content type="html"><![CDATA[<h3 id="1布局分类">1.布局分类</h3>
<p><font color=#CC3300>两种</font><br>
a: 固定宽度布局，一般宽度为 960 、 1000 、 1024px<br>
b: 不固定宽度布局，主要靠文档流的原理来布局</p>
<h3 id="2还记得吗">2.还记得吗?</h3>
<p>a: 文档流本来就是自适应的，不需要加额外的样式</p>
<pre><code>&lt;style&gt;
    span{
        border:1px solid red;
    }
&lt;/style&gt;
//它本来就会根据你页面的宽度大小来自适应
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
</code></pre><h3 id="3第三种布局">3.第三种布局</h3>
<p>a: 响应式布局<br>
b: 意思就是 pc 上固定宽度，手机上不固定宽度<br>
c: 也就是一种混合布局</p>
<h3 id="4布局的两种思路">4.布局的两种思路</h3>
<p><font color=#CC3300>① 从大到小</font><br>
先定下大局<br>
然后完善每个部分的小布局</p>
<p><font color=#CC3300>② 从小到大</font><br>
先完成小布局<br>
然后组合成大布局</p>
<p><font color=#CC3300>③ 两种均可</font><br>
新人推荐用第二种，因为小的简单<br>
老手一般用第一种，因为熟练有大局观</p>
<h3 id="4用什么-css-布局">4.用什么 css 布局</h3>
<p><img src="../../images/css%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F.PNG" alt=""></p>
<h3 id="5float-布局">5.float 布局</h3>
<p>a: 步骤<br>
-子元素上加 float:left/right 和 width<br>
-在父元素上加.clearfix(<font color=red>必须要加上</font>)</p>
<h3 id="实践">实践</h3>
<p>不同布局<br>
-用 float 做两栏布局(如顶部条)<br>
-用 float 做三栏布局(内容区)<br>
-用 float 做四栏布局(如导航)<br>
-用 float 做平均布局(如产品展示区)<br>
<a href="http://yaochengjian.com/Different-layout/1.float" target="_balck">案例展示</a></p>
<h3 id="6flex-布局">6.Flex 布局</h3>
<p>a: 让一个元素变成 flex 容器(下面是容器的属性)</p>
<pre><code>&lt;style&gt;
    .container{
        display:flex; /*或者inline-flex*/
    }
    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;
&lt;/style&gt;
</code></pre><p>b:控制它的流动方向(控制什么方向主轴就是什么方向)<br>
flex-direction:row 默认<br>
flex-direction:row-reverse 从右到左排<br>
flex-direction:cloumn<br>
flex-direction:cloumn-reverse 道理和上面一样<br>
<img src="../../images/flex-direction.png" alt=""></p>
<p>c:控制它是否折行<br>
flex-warp:nowrap 默认<br>
flex-warp:wrap 折行<br>
flex-warp:wrap-reverse 折行反转</p>
<p>d:主轴的对齐方式-默认主轴是横轴-除非改变了 flex-direction 方向<br>
justify-content:flex-start 大家都往前靠<br>
justify-content:flex-end 大家都往后靠<br>
justify-content:center 大家都往中间靠<br>
justify-content:space-between 把空间都放在中间<br>
justify-content:space-around 均匀分布两则空间<br>
<img src="../../images/justify-content.png" alt=""></p>
<p>c:次轴对齐(它会根据你主轴方向来决定自己次轴方向)<br>
align-items:flex-start<br>
algin-items:flex-end<br>
algin-items:center<br>
algin-items:stretch
<img src="../../images/algin-items.png" alt=""></p>
<p>d:次轴内容对齐方式<br>
align-content:flex-start 大家都往前靠<br>
align-content:flex-end 大家都往后靠<br>
align-content:center 大家都往中间靠(对单行是没有效果的)<br>
align-content:space-between 把空间都放在中间<br>
align-content:space-around 均匀分布两则空间</p>
<h3 id="font-colorredflex-item-有哪些属性容器里面的子元素font"><font color=red>flex item 有哪些属性(容器里面的子元素)</font></h3>
<p>a: order 属性(设置弹性盒子模型对象子元素的顺序)<br>
b：flex-grow 属性(控制自己如何长胖,默认值是 0)<br>
c：flex-shrink 属性(控制如何变瘦)一般写 flex-shrink:0 防止变瘦，默认是 1<br>
d：align-self 属性 (algin-self:flex-start algin-self:flex-end 根据次轴来决定的)</p>
<p><font color=red>flex 布局实践(不同布局)</font><br>
-用 flex 做两栏布局<br>
-用 flex 做三栏布局<br>
-用 flex 做四栏布局<br>
-用 flex 做平均布局<br>
-用 flex 组合使用，做更复杂的布局</p>
<p><a href="http://yaochengjian.com/Different-layout/2.flex" target="_balck">案例展示</a></p>
<p><font color=red>经验</font><br>
-永远不要把 width 和 height 写死，除非特殊说明<br>
-用 min-width / max-width / min-height / max-height<br>
-flex 可以基本满足所有需求<br>
-flex 和 margin-xxx:auto 配合有意外效果</p>
<p><font color=red>什么叫写死</font><br>
-写死 width:100px;<br>
不写死<br>
-width:50%<br>
-max-width:100px<br>
-width:30vw<br>
-min-width:80%<br>
-特点：不使用 px，或者加 min max 前缀</p>
<h3 id="font-colorred7grid-布局font"><font color=red>7.Grid 布局</font></h3>
<p>a: 让一个元素变成 gird 容器(下面是容器的属性)</p>
<pre><code>.container{
    display:gird | inline-grid;
}
</code></pre><p><font color=red>设置行和列</font><br>
grid-template-columns:40px 50px auto 50px 40px;<br>
grid-template-rows:25% 100px auto;
<img src="../../images/gird.png" alt=""></p>
<p><font color=red>平均布局可以这样子</font><br>
grid-template-columns:1fr 1fr 1fr;<br>
grid-template-rows:1fr 1fr 1fr;</p>
<p><font color=red>grid-template-areas</font></p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;asdie&gt;&lt;/asdie&gt;
    &lt;main&gt;&lt;/main&gt;
    &lt;div class=&quot;ad&quot;&gt;&lt;/div&gt;
    &lt;footer&gt;&lt;/footer&gt;
&lt;/div&gt;
.container{
    grid-template-areas{
        &quot;header header header&quot; /*三行三列*/
        &quot;asdie main ad&quot;
        &quot;footer footer footer&quot;
    }
}
.ad{
        grid-areas:ad
    }
</code></pre><p><font color=red>grid-gap(基本算替换了 margin 外边距)</font><br>
a：grid-gap:10px 则行和列都会生效<br>
b：grid-row-gap:10px 则行生效<br>
c：grid-column-gap:10px 则列生效</p>
<h3 id="font-colorredgrid-有哪些属性容器里面的子元素font"><font color=red>grid 有哪些属性(容器里面的子元素)</font></h3>
<p>a：grid-rows-start:1<br>
b：grid-rows-end:3<br>
c：grid-column-start:1<br>
d：grid-column-end:3</p>
<p><font color=red>复合样式：</font><br>
a：grid-row : 2 / 4 就会设置从第二行开始，到第四行结束<br>
b: grid-column : 2 / 4 就会设置从第二列开始，到第四列结束<br>
c：grid-area : 1 / 1 / 3 / 6 第一行开始，第一列开始，第三行结束，第 6 列结束<br>
<a href="http://yaochengjian.com/Different-layout/3.gird" target="_balck">案例展示</a></p>
]]></content>
        </item>
        
        <item>
            <title>10 - [css全解]定位</title>
            <link>http://yaochengjian.com/posts/10/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0810</pubDate>
            
            <guid>http://yaochengjian.com/posts/10/</guid>
            <description>问两个问题 -背景的范围是从哪到哪?(正确答案是 B)
A.border 内边沿围成的区域
B.border 外边沿围成的区域
-如何验证自己的猜想?border 半透明化
-从左边看一个 div,是什么样子?
新属性-position a：position
1.static 默认值，待在文档流里
2.relative 相对定位，升起来，但不脱离文档流
3.absolute 绝对定位，定位基准是祖先里的非 static
4.fixed 固定定位，定位基准是 viewport(有诈)
5.sticky 粘滞定位，不好描述直接举例
经验
1.如果你写了 absolute，一般都得补一个 relative
2.如果你写了 absolute 或 fixed，一定要补 top 和 left
3.sticky 兼容性很差，主要用于面试装逼
position:relative
a：使用场景
1.用于做位移对齐(很少用，现在都直接用 display:flex 了)
2.用于给 absolute 元素做爸爸
b：配合 z-index(z-index 必须配合 position 使用，否则不生效)
1.z-index:auto 默认值，不创建新层叠上下文
2.z-index：0 | 1 | 2
3.z-index:-1 | -2
经验
1.写 z-index:9999 的都是彩笔
2.学会管理 z-index
position:absolute
a：使用场景
1.脱离原来的位置，另起一层，比如对话框的关闭按钮</description>
            <content type="html"><![CDATA[<h3 id="font-colorred问两个问题font"><font color=red>问两个问题</font></h3>
<p>-背景的范围是从哪到哪?(正确答案是 B)<br>
A.border 内边沿围成的区域<br>
B.border 外边沿围成的区域<br>
-如何验证自己的猜想?border 半透明化</p>
<p>-从左边看一个 div,是什么样子?<br>
<img src="../../images/div.png" alt=""></p>
<h3 id="font-colorred新属性-positionfont"><font color=red>新属性-position</font></h3>
<p><font color=red>a：position</font><br>
1.static 默认值，待在文档流里<br>
2.relative 相对定位，升起来，但不脱离文档流<br>
3.absolute 绝对定位，定位基准是祖先里的非 static<br>
4.fixed 固定定位，定位基准是 viewport(有诈)<br>
5.sticky 粘滞定位，不好描述直接举例</p>
<p>经验<br>
1.如果你写了 absolute，一般都得补一个 relative<br>
2.如果你写了 absolute 或 fixed，一定要补 top 和 left<br>
3.sticky 兼容性很差，主要用于面试装逼</p>
<p><font color=red>position:relative</font><br>
a：使用场景<br>
1.用于做位移对齐(很少用，现在都直接用 display:flex 了)<br>
2.用于给 absolute 元素做爸爸</p>
<p>b：配合 z-index(z-index 必须配合 position 使用，否则不生效)<br>
1.z-index:auto 默认值，不创建新层叠上下文<br>
2.z-index：0 | 1 | 2<br>
3.z-index:-1 | -2</p>
<p>经验<br>
1.写 z-index:9999 的都是彩笔<br>
2.学会管理 z-index</p>
<p><font color=red>position:absolute</font><br>
a：使用场景<br>
1.脱离原来的位置，另起一层，比如对话框的关闭按钮<br>
2.鼠标提示<br>
<a href="http://yaochengjian.com/Different-layout/4.absolute" target="_black">案例</a></p>
<p>b：配合 z-index</p>
<p>经验<br>
1.absolute 相对于祖先元素中最近的的定位元素<br>
2.某些浏览器如果不写 top | left 会位置错乱<br>
3.善用 left:100%<br>
4.善用 left:50%;加负 margin</p>
<p><font color=red>position:fixed 相对于视口定位</font><br>
a：使用场景<br>
1.烦人的广告<br>
2.回到顶部按钮</p>
<p>b：配合 z-index<br>
经验<br>
1.手机上尽量不要用这个属性，坑很多</p>
<p><font color=red>层叠上下文</font><br>
a：什么会创建层叠上下文[z-index / opacity]<br>
1.每个层叠上下文就是一个作用域<br>
3.要处于同一个作用域的 z-index 才能够比较<br>
2.这一层层叠上下文会找到自己共同父级的层叠上下文作用域来进行比较(如果没有就默认是 html)</p>
]]></content>
        </item>
        
        <item>
            <title>11 - [css动画]</title>
            <link>http://yaochengjian.com/posts/11/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0811</pubDate>
            
            <guid>http://yaochengjian.com/posts/11/</guid>
            <description>transform 完整介绍 a: translate(平移)
 translateX(长度 | 百分比) translateY(长度 | 百分比) translate(x 轴,y 轴) translateX(50%) 往右边偏移自身宽度的一半  translate(-50%,-50%) 可做绝对定位元素居中
b: scale(缩放)
 scaleX(number) scaleY(number) scale(X-number,Y-number)  用得较少，因为容易出现模糊
c: rotate(旋转)
d: transform-origin 设置旋转点
 rotate(度数) 沿 Z 轴转动 rotateX(度数) rotateY(度数)  e: skew(倾斜)
 skewX(度数) skewY(度数) skew(X,Y)  用得较少
案例 爱心
transition 过渡 a: 语法
 transition-property 状态发生变化的属性(可以用 all 代表所有属性) transition-timing-function 过渡变化的速度 transition-delay 延迟多长时间开始 transition:width 3s , background 3s(这样我们可以采用多种属性一起过渡) 过渡方式有: ease : 速度逐渐变慢，这是默认值</description>
            <content type="html"><![CDATA[<h3 id="font-colorredtransform-完整介绍font"><font color=red>transform 完整介绍</font></h3>
<p>a: translate(平移)</p>
<ol>
<li>translateX(长度 | 百分比)</li>
<li>translateY(长度 | 百分比)</li>
<li>translate(x 轴,y 轴)</li>
<li>translateX(50%) <font color=red>往右边偏移自身宽度的一半</font></li>
</ol>
<p>translate(-50%,-50%) 可做绝对定位元素居中</p>
<p>b: scale(缩放)</p>
<ol>
<li>scaleX(number)</li>
<li>scaleY(number)</li>
<li>scale(X-number,Y-number)</li>
</ol>
<p>用得较少，因为容易出现模糊</p>
<p>c: rotate(旋转)<br>
d: transform-origin 设置旋转点</p>
<ol>
<li>rotate(度数) 沿 Z 轴转动</li>
<li>rotateX(度数)</li>
<li>rotateY(度数)</li>
</ol>
<p>e: skew(倾斜)</p>
<ol>
<li>skewX(度数)</li>
<li>skewY(度数)</li>
<li>skew(X,Y)</li>
</ol>
<p>用得较少<br>
案例 <a href="http://yaochengjian.com/Different-layout/6.爱心">爱心</a></p>
<h3 id="font-colorredtransition-过渡font"><font color=red>transition 过渡</font></h3>
<p>a: 语法</p>
<ol>
<li>transition-property 状态发生变化的属性(可以用 all 代表所有属性)</li>
<li>transition-timing-function 过渡变化的速度</li>
<li>transition-delay 延迟多长时间开始</li>
<li>transition:width 3s , background 3s(这样我们可以采用多种属性一起过渡)</li>
<li>过渡方式有:
ease : 速度逐渐变慢，这是默认值<br>
linear : 均速<br>
ease-in : 以慢速开始<br>
ease-in-out : 慢速开始 -&gt; 再快速 -&gt; 再慢速</li>
</ol>
<p>b: <font color=red>注意:并不是所有属性都能过渡</font></p>
<ol>
<li>display:none =&gt; block 没法过渡</li>
<li>一般改成 visibility:hidden =&gt; visible</li>
<li>transition 是一次性的，不能重复发生，触发多次</li>
<li>transition 只能定义开始和结束状态，不能定义中间状态，也就是说只有两个状态</li>
</ol>
<h3 id="font-colorredanimation-动画font"><font color=red>animation 动画</font></h3>
<p><font color=red>a: 语法</font></p>
<pre><code>第一种
@keyframs name{
    form{}
    to{}
}
第二种
@keyframs name{
    0%{}
    20%{}
    100%{}
}
</code></pre><p><font color=red>b:缩写语法</font><br>
animation: 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停 | 动画名</p>
<ol>
<li>过渡方式 : 跟 transition 取值一样</li>
<li>次数 : 自定义次数或者 infinite(无数次)</li>
<li>方向 : reverse | alternate(原路返回) | alternate-reverse</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>12 - [HTTP全解]URL是什么</title>
            <link>http://yaochengjian.com/posts/12/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0812</pubDate>
            
            <guid>http://yaochengjian.com/posts/12/</guid>
            <description>1.域名是什么 a: 域名实际上是 ip 的别称 知识点
  一个域名可以对应不同 IP
这个叫做均衡负载，防止一台机器扛不住
  一个 IP 可以对应不同域名
这个叫做共享主机，穷开发者会这么做
  域名和 IP 是怎么对应起来的？
通过 DNS
  当你输入 xiedaimala.com
  过程
-你的 Chrom 浏览器会向电信|联通提供的 DNS 服务器询问 xiedaimala.com 对应 IP
-电信|联通会回答一个 IP(具体过程很复杂，不研究)
-然后 Chrome 才会想对应 IP 的 80/443 端口发送请求
-请求内容是查看 xiedaimala.com 的首要
为什么是 80 或 443 端口
-服务器默认用 80 提供 http 服务
-服务器默认用 443 提供 https 服务
-你可以在开发者工具里看到具体的端口
如何请求不同的页面
-路径可以做到(不同的路径可以请求不同的页面)
同一个页面，不同内容</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1域名是什么font"><font color=red>1.域名是什么</font></h3>
<p>a: 域名实际上是 ip 的别称
知识点</p>
<ol>
<li>
<p>一个域名可以对应不同 IP<br>
这个叫做均衡负载，防止一台机器扛不住</p>
</li>
<li>
<p>一个 IP 可以对应不同域名<br>
这个叫做共享主机，穷开发者会这么做</p>
</li>
<li>
<p>域名和 IP 是怎么对应起来的？<br>
通过 DNS</p>
</li>
<li>
<p>当你输入 xiedaimala.com</p>
</li>
</ol>
<p><font color=red>过程</font><br>
-你的 Chrom 浏览器会向电信|联通提供的 DNS 服务器询问 xiedaimala.com 对应 IP<br>
-电信|联通会回答一个 IP(具体过程很复杂，不研究)<br>
-然后 Chrome 才会想对应 IP 的 80/443 端口发送请求<br>
-请求内容是查看 xiedaimala.com 的首要</p>
<p><font color=red>为什么是 80 或 443 端口</font><br>
-服务器默认用 80 提供 http 服务<br>
-服务器默认用 443 提供 https 服务<br>
-你可以在开发者工具里看到具体的端口</p>
<p><font color=red>如何请求不同的页面</font><br>
-路径可以做到(不同的路径可以请求不同的页面)</p>
<p><font color=red>同一个页面，不同内容</font><br>
查询参数可以做到<br>
-www.baidu.com/s?wd=hi<br>
-www.baidu.com/s?wd=hello</p>
<p><font color=red>URL 组成</font><br>
<a href="https://www.baidu.com/s?wd=hello#5">https://www.baidu.com/s?wd=hello#5</a><br>
协议+域名或 IP+端口号+路径+查询字符串+锚点</p>
<p><font color=red>DNS 作用是什么</font></p>
<ol>
<li>DNS 就是把域名和 IP 地址联系在一起，有了 DNS 服务，你就不用输入 IP 地址来访问一个网站了，就可以通过输入网址来访问(解析 IP)</li>
<li>nslookup 用法 : nslookup + 查询对应的域名 [可以得到对应的域名 IP 地址]</li>
</ol>
<p><font color=red>域名是什么?分别哪几类域名</font></p>
<ol>
<li>.com 商业性的机构或公司</li>
<li>.cn 中国域名</li>
<li>.top 机构公司个人</li>
<li>.org 非盈利的组织、团体 &hellip;&hellip;</li>
</ol>
<p><font color=red>curl 命令</font></p>
<ol>
<li>用 curl 可以发 HTTP 请求
-curl <a href="http://baidu.com">http://baidu.com</a><br>
-curl -v <a href="http://baidu.com">http://baidu.com</a> (加-v 可以看到更详细的内容)</li>
<li>理解一下概念<br>
-url 会被 curl 工具重写，先请求 DNS 获得 IP<br>
-先进行 TCP 连接，TCP 连接成功后，开始发送 HTTP 请求<br>
-请求内容看一眼<br>
-响应内容看一眼</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>13 - [HTTP全解]请求和响应 &amp; Node.js server</title>
            <link>http://yaochengjian.com/posts/13/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0813</pubDate>
            
            <guid>http://yaochengjian.com/posts/13/</guid>
            <description>演示 Node.js Server   前置条件
-安装 Node.js 8 +
-理解 IP 和端口
-理解 URL 路径和查询参数
  如何发请求
-用 Chrome 地址栏
-用 curl 命令
  模拟客户端向服务器端请求内容
-在 github.com/FrankFang/nodejs-test/blob/master/server.js 下载
-一般这个文件是放在服务器上面，而不是自己的机器上
  response.setHeader(&amp;ldquo;Content-Type&amp;rdquo;,&amp;ldquo;text/css;charset=utf-8&amp;rdquo;) 让服务器告诉浏览器它发送的数据属于什么文件类型
response.write() 写入响应内容发送回给浏览器
response.end() 响应结束
  HTTP 基础概念   请求(Request Headers)[get 是获取内容，post 是上传内容]
-请求动词 路径 + 查询参数 协议名/版本 [请求行]
-Host: 域名或 IP [这三行是请求头]
Accept: text/html
Content-Type: 请求体的格式
-请求体[也就是上传的内容]
curl -v -X POST &amp;ndash;data &amp;lsquo;上传内容&amp;rsquo; http://localhost:8888/</description>
            <content type="html"><![CDATA[<h3 id="font-colorred演示-nodejs-serverfont"><font color=red>演示 Node.js Server</font></h3>
<ol>
<li>
<p>前置条件<br>
-安装 Node.js 8 +<br>
-理解 IP 和端口<br>
-理解 URL 路径和查询参数</p>
</li>
<li>
<p>如何发请求<br>
-用 Chrome 地址栏<br>
-用 curl 命令</p>
</li>
<li>
<p>模拟客户端向服务器端请求内容<br>
-在 github.com/FrankFang/nodejs-test/blob/master/server.js 下载<br>
-一般这个文件是放在服务器上面，而不是自己的机器上</p>
</li>
<li>
<p>response.setHeader(&ldquo;Content-Type&rdquo;,&ldquo;text/css;charset=utf-8&rdquo;) 让服务器告诉浏览器它发送的数据属于什么文件类型<br>
response.write() 写入响应内容发送回给浏览器<br>
response.end() 响应结束</p>
</li>
</ol>
<h3 id="font-colorredhttp-基础概念font"><font color=red>HTTP 基础概念</font></h3>
<ol>
<li>
<p>请求(Request Headers)[get 是获取内容，post 是上传内容]<br>
-请求动词 路径 + 查询参数 协议名/版本 [请求行]</p>
<p>-Host: 域名或 IP [这三行是请求头]<br>
Accept: text/html<br>
Content-Type: 请求体的格式</p>
<p>-请求体[也就是上传的内容]<br>
curl -v -X POST &ndash;data &lsquo;上传内容&rsquo; http://localhost:8888/</p>
</li>
<li>
<p>响应(Response Headers)<br>
-协议名/版本 状态码 状态字符串 [状态行]</p>
<p>-Content-Type: 响应体的格式 [响应头]</p>
<p>-响应体 Response[也就是下载内容]</p>
</li>
</ol>
<h3 id="font-colorred用-curl-构造请求font"><font color=red>用 curl 构造请求</font></h3>
<ol>
<li>
<p>设置请求动词(加上-X)<br>
curl -v -X POST http://localhost:8888</p>
</li>
<li>
<p>设置路径和查询参数<br>
curl -v -X POST http://localhost:8888/xxx?wd=hello#nihao<br>
直接在 url 后面加(锚点是不会发送到服务器上面的)</p>
</li>
<li>
<p>设置 请求头(加上-H,可以任意设置)<br>
curl -v -H &ldquo;Accept:text/html&rdquo; http://localhost:8888<br>
curl -v -H &ldquo;Content-type:text/html&rdquo; http://localhost:8888</p>
</li>
<li>
<p>设置请求体(加上-d)<br>
curl -v -d &ldquo;你好吗?&rdquo; http://localhost:8888</p>
</li>
<li>
<p>用 Node.js 读取请求<br>
-设置响应状态码<br>
response.statusCode = 200</p>
<p>-设置响应头<br>
response.setHeader(&lsquo;Content-Type&rsquo;,&lsquo;text/html&rsquo;)</p>
<p>-设置响应体<br>
response.write(&lsquo;内容&rsquo;)</p>
</li>
</ol>
<h3 id="font-colorredssh-远程登录-阿里云-ubuntufont"><font color=red>ssh 远程登录-阿里云 Ubuntu</font></h3>
<ol>
<li>
<p>首先登录远程服务器</p>
</li>
<li>
<p>成功看到 welcome 之后</p>
</li>
<li>
<p>echo &lsquo;复制本地~/.ssh/id_rsa.pub 内容&rsquo; &raquo; /.ssh/authorized_keys</p>
</li>
<li>
<p>新建终端，在本地运行 ssh root@实例公网 ip</p>
</li>
<li>
<p>此时就可以在本地终端操作云服务器了</p>
</li>
<li>
<p>你可以在 hosts 文件里给实例 ip 取个别名</p>
</li>
<li>
<p>想要退出云机器，可以输入 exit 回车</p>
</li>
<li>
<p>如果卡了，可以直接退出终端 ctrl + w</p>
</li>
</ol>
<p><font color=red>创建应用账户(为什么?)</font></p>
<ol>
<li>
<p>linux 的 root 账户拥有最高权限，一旦被攻克机器就完全被人控制(步骤)<br>
a. adduser chengjian<br>
b. Enter new UNIX password : 输入密码<br>
c. 再次输入密码,密码可以跟 root 的密码一样<br>
d. 一直回车，知道结束，运行如下命令<br>
e. mkdir /home/chengjian/.ssh<br>
f. cp ~/.ssh/authorized_keys /home/chengjian/.ssh/<br>
g. chmod 755 /home/chengjian/.ssh/authorized_keys<br>
h. chown chengjian:chengjian /home/chengjian/.ssh/authorized_keys</p>
</li>
<li>
<p>给 chengjian 添加 sudu 权限(sudo 是什么)<br>
a. adduser chengjian sudo<br>
b. 类似于 Windows 的[以管理员身份运行]<br>
c. 平时你不应该使用 root 账户，而是用 chengjian 账户<br>
d. 遇到特殊操作，就在前面加 sudo,请出 root<br>
e. 需要输入 chengjian 的密码，不是 root 密码<br>
f. sudo !!的意思是用 sudo 执行上一句命令</p>
</li>
</ol>
<h3 id="font-colorred在服务器上面安装-nodejs-8-和-git步骤font"><font color=red>在服务器上面安装 Node.js 8 和 git(步骤)</font></h3>
<ol>
<li>
<p>curl -sL <a href="https://deb.nodesource.com/setup_8.x">https://deb.nodesource.com/setup_8.x</a> | sudo bash -</p>
</li>
<li>
<p>sudo sed -i &lsquo;s/deb.nodesource.com/node_8.x/mirrors.tuna.tsinghua.edu.cn/nodesource/deb_8.x/g&rsquo; /etc/apt/sources.list.d/nodesource.list</p>
</li>
<li>
<p>sudo apt-get update</p>
</li>
<li>
<p>sudo apt-get install -y nodejs</p>
</li>
<li>
<p>sudo apt install git</p>
</li>
<li>
<p>遇到[Y/n]输入回车，或者 Y 回车</p>
</li>
<li>
<p>git &ndash;version</p>
</li>
</ol>
<h3 id="font-colorred在服务器上面部署-nodejs-代码font"><font color=red>在服务器上面部署 node.js 代码</font></h3>
<ol>
<li>下载代码(不要使用 ssh 地址，使用 https)
git clone (GitHub 上 https 下载地址)</li>
<li>启动<br>
a. cd node-demo-1<br>
b. touch log(创建 log 文件，后面可以查看到请求进程)<br>
c. node server.js 8888 &gt; log 2&gt;&amp;1 &amp;<br>
d. kill -9 pid 可以关掉进程<br>
e. tail log(可以查看 log 请求进程内容)<br>
f. killall node 可以关掉所有 node 进程<br>
g. git pull 会在 github 拉取最新的代码</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>14 - [JS全解]JS的诞生</title>
            <link>http://yaochengjian.com/posts/14/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0814</pubDate>
            
            <guid>http://yaochengjian.com/posts/14/</guid>
            <description>1.Javascript 的 10 个设计缺陷  不适合开发大型程序 非常小的标准库 null 和 undefined  null属于对象的一种，意思是该对象为空;undefined则是一种数据类型，表示未定义(typeof 出来是字符串类型)typeof null // objecttypeof undefined // undefined全局变量难以控制 自动插入行尾分号 加号运算符  + 号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接console.log(1 + 10)console.log(&amp;quot;1&amp;quot; + 10)NaN(NaN 自己也不等于自己)  NaN === NaN //falseNaN !== NaN //true数据和对象区分(数组也属于对象) == 和 ===   == 只是判断两个值是否相等=== 不单单判断值是否相等，还判断两边类型是否相等基本类型的包装对象  Javascript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。new Boolean(false);new Number(1234);new String(&amp;quot;Hello World&amp;quot;);与基本数据类型对应的对象类型，作用很小，造成的混淆却很大。alert( typeof 1234); // numberalert( typeof new Number(1234)); // object2.</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1javascript-的-10-个设计缺陷font"><font color=red>1.Javascript 的 10 个设计缺陷</font></h3>
<ol>
<li>不适合开发大型程序</li>
<li>非常小的标准库</li>
<li>null 和 undefined</li>
</ol>
<pre><code>null属于对象的一种，意思是该对象为空;undefined则是一种数据类型，表示未定义(typeof 出来是字符串类型)
typeof null // object
typeof undefined // undefined
</code></pre><ol start="4">
<li>全局变量难以控制</li>
<li>自动插入行尾分号</li>
<li>加号运算符</li>
</ol>
<pre><code>+ 号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接
console.log(1 + 10)
console.log(&quot;1&quot; + 10)
</code></pre><ol start="7">
<li>NaN(NaN 自己也不等于自己)</li>
</ol>
<pre><code>NaN === NaN  //false
NaN !== NaN  //true
</code></pre><ol start="8">
<li>数据和对象区分(数组也属于对象)</li>
<li>== 和 ===</li>
</ol>
<pre><code>  == 只是判断两个值是否相等
  === 不单单判断值是否相等，还判断两边类型是否相等
</code></pre><ol start="10">
<li>基本类型的包装对象</li>
</ol>
<pre><code>Javascript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。
　　new Boolean(false);

　　new Number(1234);

　　new String(&quot;Hello World&quot;);

与基本数据类型对应的对象类型，作用很小，造成的混淆却很大。
　　alert( typeof 1234); // number

　　alert( typeof new Number(1234)); // object
</code></pre><h3 id="font-colorred2a-href--httpswwwjianshucomp33c1d8505975js-的历史afont"><font color=red>2.<a href = "https://www.jianshu.com/p/33c1d8505975">JS 的历史</a></font></h3>
<h3 id="font-colorred3a-href--httpwwwruanyifengcomblog201106birth_of_javascripthtmljs-的诞生afont"><font color=red>3.<a href = "http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html">JS 的诞生</a></font></h3>
]]></content>
        </item>
        
        <item>
            <title>15 - [JS全解]内存图与JS世界</title>
            <link>http://yaochengjian.com/posts/15/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0815</pubDate>
            
            <guid>http://yaochengjian.com/posts/15/</guid>
            <description>浏览器功能 1.发起请求，下载 HTML,解析 HTML，下载 CSS，解析 CSS，渲染界面,下载 JS，解析 JS，执行 JS 等
2.JS 是单线程的，一个页面只能开一个渲染引擎和 JS 引擎，线程不能在开线程
JS 原型 1.所有的函数(函数也是对象,函数也是类)数据类型都天生自带一个属性:prototype(原型),这个属性的值是一个对象
2.在浏览器给 prototype 开辟的堆内存中有一个天生自带的属性:constructor，这个属性存储的值是当前函数本身
Array.prototype.constructor === Array3.每一个对象都有一个__ proto__的属性，这个属性指向当前实例所属类的原型(如果不能确定是谁的实例，都是 Object 的实例)
4.每一个类把供实例调取的公共属性方法，存储到自己原型上(原型 prototype 的作用就是存储一些公共的属性和方法，供它的实例调取使用)
原型链__proto__
1.它是一种基于__proto__向上查找机制。当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性
2.找到了，则结束查找，使用自己私有的即可
3.没有找到，则基于__proto__找所属类的 prototype，如果找到就用这个公有的，如果没找到，基于原型上的__proto__向上查找，一直找到 Object.prototype 的原型为止，如果在没有，操作的属性或者方法不存在 </description>
            <content type="html"><![CDATA[<h3 id="font-colorred浏览器功能font"><font color=red>浏览器功能</font></h3>
<p>1.发起请求，下载 HTML,解析 HTML，下载 CSS，解析 CSS，渲染界面,下载 JS，解析 JS，执行 JS 等</p>
<p>2.JS 是单线程的，一个页面只能开一个渲染引擎和 JS 引擎，线程不能在开线程</p>
<h3 id="font-colorredjs-原型font"><font color=red>JS 原型</font></h3>
<p>1.所有的函数(函数也是对象,函数也是类)数据类型都天生自带一个属性:prototype(原型),这个属性的值是一个对象<br>
2.在浏览器给 prototype 开辟的堆内存中有一个天生自带的属性:constructor，这个属性存储的值是当前函数本身</p>
<pre><code>Array.prototype.constructor === Array
</code></pre><p>3.每一个对象都有一个__ proto__的属性，这个属性指向当前实例所属类的原型(如果不能确定是谁的实例，都是 Object 的实例)<br>
4.每一个类把供实例调取的公共属性方法，存储到自己原型上(原型 prototype 的作用就是存储一些公共的属性和方法，供它的实例调取使用)</p>
<p><font color=red>原型链__proto__</font><br>
1.它是一种基于__proto__向上查找机制。当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性<br>
2.找到了，则结束查找，使用自己私有的即可<br>
3.没有找到，则基于__proto__找所属类的 prototype，如果找到就用这个公有的，如果没找到，基于原型上的__proto__向上查找，一直找到 Object.prototype 的原型为止，如果在没有，操作的属性或者方法不存在
<img src="../../images/%E5%8E%9F%E5%9E%8B.png" alt=""></p>
]]></content>
        </item>
        
        <item>
            <title>16 - [JS全解]canvas实践</title>
            <link>http://yaochengjian.com/posts/16/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0816</pubDate>
            
            <guid>http://yaochengjian.com/posts/16/</guid>
            <description>Canvas(不能在 css 设置宽高[不支持]) 绘制矩形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.fillStyle = &amp;ldquo;black&amp;rdquo; 定义路径内容区域颜色
3.ctx.fillRect(x,y,width,height)
4.ctx.fill() 填充路径的内容区域生成实心图形
绘制三角形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.strokeStyle = &amp;lsquo;red&amp;rsquo; 定义描边内容区域颜色
2.ctx.beginPath() 绘制一个新的形状路径开始
3.ctx.moveTo(x,y)
4.ctx.lineTo(x,y)
5.ctx.stroke() 填充描边路径颜色
6.ctx.lineWidth 定义线的粗心状态
7.ctx.lineCap 每个点与点连接是圆的
绘制圆形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.fillStyle = &amp;lsquo;red&amp;rsquo;
3.ctx.beiginPath() 绘制一个新的形状路径开始
3.ctx.arc(x,y,半径，圆开始，弧度)
4.ctx.fill()
需要注意的细节 1.document.body.clientWidth : 获取 body 的宽度(小细节:body 的高度是根据内容高度撑开的)
2.document.body.clientHeigh : 获取 body 的高度
3.document.documentElement.clientWidth : 获取 HTML 的宽度
4.document.documentElement.clientHeight : 获取 HTML 的高度
var ctx = canvas.</description>
            <content type="html"><![CDATA[<h3 id="font-colorredcanvas不能在-css-设置宽高不支持font"><font color=red>Canvas(不能在 css 设置宽高[不支持])</font></h3>
<p><font color=red>绘制矩形</font><br>
1.var ctx = canvas.getContext(&lsquo;2d&rsquo;)<br>
2.ctx.fillStyle = &ldquo;black&rdquo; 定义路径内容区域颜色<br>
3.ctx.fillRect(x,y,width,height)<br>
4.ctx.fill() 填充路径的内容区域生成实心图形</p>
<p><font color=red>绘制三角形</font><br>
1.var ctx = canvas.getContext(&lsquo;2d&rsquo;)<br>
2.ctx.strokeStyle = &lsquo;red&rsquo; 定义描边内容区域颜色<br>
2.ctx.beginPath() 绘制一个新的形状路径开始<br>
3.ctx.moveTo(x,y)<br>
4.ctx.lineTo(x,y)<br>
5.ctx.stroke() 填充描边路径颜色<br>
6.ctx.lineWidth 定义线的粗心状态<br>
7.ctx.lineCap 每个点与点连接是圆的</p>
<p><font color=red>绘制圆形</font><br>
1.var ctx = canvas.getContext(&lsquo;2d&rsquo;)<br>
2.ctx.fillStyle = &lsquo;red&rsquo;<br>
3.ctx.beiginPath() 绘制一个新的形状路径开始<br>
3.ctx.arc(x,y,半径，圆开始，弧度)<br>
4.ctx.fill()</p>
<p><font color=red>需要注意的细节</font>
1.document.body.clientWidth : 获取 body 的宽度(小细节:body 的高度是根据内容高度撑开的)<br>
2.document.body.clientHeigh : 获取 body 的高度<br>
3.document.documentElement.clientWidth : 获取 HTML 的宽度<br>
4.document.documentElement.clientHeight : 获取 HTML 的高度</p>
<pre><code>var ctx = canvas.getContext(&quot;2d&quot;);
ctx.fillStyle = &quot;rgb(200,0,0)&quot;;
ctx.fillRect(10,10,55,50);
</code></pre>]]></content>
        </item>
        
        <item>
            <title>17 - [JS全解]JS语法</title>
            <link>http://yaochengjian.com/posts/17/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0817</pubDate>
            
            <guid>http://yaochengjian.com/posts/17/</guid>
            <description>1.JS 版本 历史版本
ES3，IE6 支持，总体评价 : 垃圾
ES5，总体评价 : 还是垃圾
ES6，大部分浏览器支持，总体评价 : 一半垃圾一半好
ES2019 与 ES6 差别不大
为什么说 ES6 一半垃圾
因为 ES 不能删除以前的特性，要兼容旧的网站
也就是说以前能运行的网站，以后都要能运行
对比 Python3 你就知道兼容的好处 : 稳定
2.表达式与语句 表达式
 1+2 表达式的值为 3 add(1,2)表达式的值为函数的返回值 console.log 表达式的值为函数本身 console.log(3) 表达式的值为多少? undefined  语句
 var a = 1 是一个语句  二者的区别
 表达式一般都有值，语句可能有也可能没有 语句一般会改变环境(声明、赋值) 上面两句话并不是绝对的  3.空格  大部分空格没有实际意义 只有一个地方不能加回车，那就是 return 后面，加了函数调用会返回一个 undefined SYntaxError : 语法错误  4.区块 block {把代码包在一起let a = 1;let b = 2;}常常与 if / for / while 合用</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1js-版本font"><font color=red>1.JS 版本</font></h3>
<p><font color=red>历史版本</font><br>
ES3，IE6 支持，总体评价 : 垃圾<br>
ES5，总体评价 : 还是垃圾<br>
ES6，大部分浏览器支持，总体评价 : 一半垃圾一半好<br>
ES2019 与 ES6 差别不大</p>
<p><font color=red>为什么说 ES6 一半垃圾</font><br>
因为 ES 不能删除以前的特性，要兼容旧的网站<br>
也就是说以前能运行的网站，以后都要能运行<br>
对比 Python3 你就知道兼容的好处 : 稳定</p>
<h3 id="font-colorred2表达式与语句font"><font color=red>2.表达式与语句</font></h3>
<p><font color=red>表达式</font></p>
<ol>
<li>1+2 表达式的值为 3</li>
<li>add(1,2)表达式的值为函数的返回值</li>
<li>console.log 表达式的值为函数本身</li>
<li>console.log(3) 表达式的值为多少? undefined</li>
</ol>
<p><font color=red>语句</font></p>
<ol>
<li>var a = 1 是一个语句</li>
</ol>
<p><font color=red>二者的区别</font></p>
<ol>
<li>表达式一般都有值，语句可能有也可能没有</li>
<li>语句一般会改变环境(声明、赋值)</li>
<li>上面两句话并不是绝对的</li>
</ol>
<h3 id="font-colorred3空格font"><font color=red>3.空格</font></h3>
<ol>
<li>大部分空格没有实际意义</li>
<li>只有一个地方不能加回车，那就是 return 后面，加了函数调用会返回一个 undefined</li>
<li>SYntaxError : 语法错误</li>
</ol>
<h3 id="font-colorred4区块-blockfont"><font color=red>4.区块 block</font></h3>
<pre><code>{
    把代码包在一起
    let a = 1;
    let b = 2;
}
</code></pre><p>常常与 if / for / while 合用</p>
<h3 id="font-colorred5if-语句font"><font color=red>5.if 语句</font></h3>
<p><font color=red>语句</font></p>
<ol>
<li>if(表达式){语句 1}else{语句 2}</li>
<li>{}在语句只有一句的时候可以省略，不建议这样做</li>
</ol>
<p><font color=red>变态情况</font></p>
<ol>
<li>表达式里可以非常变态，如 a = 1</li>
<li>语句 1 里可以非常变态，如嵌套的 if else</li>
<li>语句 2 里可以非常变态，如嵌套的 if else</li>
</ol>
<pre><code>
a = 1
if(a === 2)   这里其实有一个无形的{}，条件成立了依然会执行，只会管第一句话
  console.log('a');
  console.log('b');
</code></pre><h3 id="font-colorred6switch-语句font"><font color=red>6.switch 语句</font></h3>
<p><font color=red>语法</font></p>
<pre><code>switch(a){
    case 1:
    console.log(1);
        break;
    case 2:
    console.log(2);
        break;
    case 3:
    case 4:
    console.log(3,4);
        break;
    default:
    console.log(&quot;hi&quot;);
}
</code></pre><ol>
<li>大部分时候，省略 break 你就完了</li>
<li>少部分时候，可以利用 break</li>
</ol>
<h3 id="font-colorred7问好冒号表达式font"><font color=red>7.问好冒号表达式</font></h3>
<ol>
<li>表达式 1 ? 表达式 2 : 表达式 3</li>
</ol>
<pre><code>var a = 10;
var b = 20;
a &gt; b ? console.log(a) ? console.log(b);
</code></pre><h3 id="font-colorred8-短路逻辑font"><font color=red>8.&amp;&amp; ||短路逻辑</font></h3>
<ol>
<li>A &amp;&amp; B 如果 A 是是假，就取 A! 如果 A 是真，就会取 B</li>
<li>A || B 如果 A 是真，就直接取 A(始终会取一个真值)，全部是假就会取最后一个</li>
</ol>
<h3 id="font-colorred9for-循环font"><font color=red>9.for 循环</font></h3>
<p><font color=red>语法</font></p>
<pre><code>for(语句1;表达式2;语句3){
    循环体
}
</code></pre><ol>
<li>先执行语句 1</li>
<li>然后判断表达式 2</li>
<li>如果为真，执行循环体，然后执行语句 3</li>
<li>如果为假，直接退出循环，执行后面的语句</li>
</ol>
<p><font color=red>10.break 和 coontinue</font></p>
<ol>
<li>break 退出当前循环</li>
<li>continent 退出当前一次循环</li>
</ol>
<p><font color=red>11.label 语句</font><br>
一般不会使用，面试中会遇到 : 举例</p>
<pre><code>{
    foo : 1
}
</code></pre><p>面试中会被问 : 上述是什么东西?<br>
我们的回答就是 : 这就是一个 label，它的内容为 1</p>
]]></content>
        </item>
        
        <item>
            <title>18 - [JS全解]JS数据类型</title>
            <link>http://yaochengjian.com/posts/18/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0818</pubDate>
            
            <guid>http://yaochengjian.com/posts/18/</guid>
            <description>1.用 0~127 表示所有符号  48~57 表示数字符号 65~90 表示大写字母 97~122 表示小写字母  2.JS 中的数据类型(7 种)   数字 number
  字符串 string
1.写法&#39;你好&#39; 单引号&amp;quot;你好&amp;quot; 双引号`你好` 反引号2.转义&#39;it&#39;s ok&#39; js引擎会认为&#39;it&#39;就结束了，后面的看不懂&#39;it \&#39;s ok&#39; 这就是转义3.如果你想要在字符串里回车可以使用反引号``let s = `这样是可以的用反引号很容易做到`4.通过下标读取字符(下标是从0开始)let s = &#39;hello&#39;;s[0]; //&#39;h&#39;  布尔 bool
 1.五个falsy值(falsy就是相当于false但又不是false的值)分别是[undefined 、null、0、NaN、&#39;&#39;]  符号 symbol
  未定义 undefined
  空 null</description>
            <content type="html"><![CDATA[<h3 id="font1用-0127-表示所有符号font"><font>1.用 0~127 表示所有符号</font></h3>
<ol>
<li>48~57 表示数字符号</li>
<li>65~90 表示大写字母</li>
<li>97~122 表示小写字母</li>
</ol>
<h3 id="font-colorred2js-中的数据类型7-种font"><font color=red>2.JS 中的数据类型(7 种)</font></h3>
<ol>
<li>
<p>数字 number</p>
</li>
<li>
<p>字符串 string</p>
<pre><code>1.写法
 '你好'  单引号
 &quot;你好&quot;  双引号
 `你好`  反引号

2.转义
 'it's ok' js引擎会认为'it'就结束了，后面的看不懂
 'it \'s ok' 这就是转义

3.如果你想要在字符串里回车可以使用反引号``
  let s = `这样是
  可以的
  用反引号很容易做到`

4.通过下标读取字符(下标是从0开始)
  let s = 'hello';
  s[0]; //'h'
</code></pre></li>
<li>
<p>布尔 bool</p>
<pre><code> 1.五个falsy值(falsy就是相当于false但又不是false的值)
   分别是[undefined 、null、0、NaN、'']
</code></pre></li>
<li>
<p>符号 symbol</p>
</li>
<li>
<p>未定义 undefined</p>
</li>
<li>
<p>空 null</p>
<pre><code>区别
 1.如果一个变量声明了，但没有赋值，那么默认值就是undefined，而不是null
 2.如果一个函数，没有写return，那么默认return undefined，而不是null
 3.undefined更多是默认的空，null是主动的空
</code></pre></li>
<li>
<p>对象 object</p>
</li>
</ol>
<h3 id="font-colorred3特殊值font"><font color=red>3.特殊值</font></h3>
<ol>
<li>正 0 和 负 0</li>
<li>无穷大 (Infinity 、+Infinity 、-Infinity)</li>
<li>无法表示的数字 (NaN)</li>
</ol>
<h3 id="font-colorred4变量声明font"><font color=red>4.变量声明</font></h3>
<ol>
<li>三种声明方式</li>
</ol>
<pre><code>   var a = 1;
   let a = 1;
   const a = 1

   区别
   1.var是过时的、不好用的方式
   2.let是新的，更合理的方式
   3.const是声明是必须赋值，且不能再改的方式

   let 声明[规则]
   1.遵循块作用域，即使用范围不能超出{}
   2.不能重复声明
   3.可以赋值，也可以不赋值
   4.必须先声明再使用，否则报错
   5.全局声明的let变量，不会变成window的属性
   6.for循环配合let有奇效

   const 声明[规则]
   1.跟let几乎一样
   2.只有一条不一样 : 声明时就要赋值，赋值后不能改
</code></pre><h3 id="font-colorred5类型转换font"><font color=red>5.类型转换</font></h3>
<pre><code>1. number =&gt; string  数字转字符串
   String(n)
   n + ''

2. string =&gt; number  字符串转数字
   Number(s)
   parseInt(s) / parseFloat(s)
   s - 0
   +s

3. x =&gt; boll  转为布尔型
   Boolean(x)
   !!x

4. x =&gt; string  把任何东西转为字符串
   String(x)
   x.toString()
</code></pre><p>秘密花园是讲 JavaScript 各种奇葩之处</p>
]]></content>
        </item>
        
        <item>
            <title>19 - [JS全解]JS对象</title>
            <link>http://yaochengjian.com/posts/19/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0819</pubDate>
            
            <guid>http://yaochengjian.com/posts/19/</guid>
            <description>1.对象 object 对象定义
无序的数据集合键值对的集合let obj = {&#39;name&#39; : &#39;chengjian&#39;,&#39;age&#39; : 18}let obj = new Object({&#39;name&#39; : &#39;chengjian&#39;})细节1.键名是字符串，不是标识符，可以包含任意字符2.引号可省略3.就算引号省略了，键名也还是字符串(重要)4.Object.keys(obj)可以得到obj的所有key变量作属性名
let p1 = &amp;quot;name&amp;quot;;let obj = {p1 : &#39;chengjian&#39;} 这样写，属性名为&#39;p1&#39;let obj = {[p1] : &#39;chengjian&#39;} 这样写，属性名为&#39;name&#39;1.不加[]的属性名会自动变成字符串2.加了[]则会当做变量求值3.值如果不是字符串，则会自动变成字符串2.对象增删改查 删除
 let obj = {a : chengjian}console.log(&#39;xxx&#39; in obj)1.不含属性名&#39;a&#39; in obj2.含有属性名，但是值为undefined&#39;a&#39; in obj &amp;amp;&amp;amp; obj.</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1对象-objectfont"><font color=red>1.对象 object</font></h3>
<p><font color=red>对象定义</font></p>
<pre><code>无序的数据集合
键值对的集合
let obj = {
    'name' : 'chengjian',
    'age'  : 18
}

let obj = new Object({'name' : 'chengjian'})

细节
1.键名是字符串，不是标识符，可以包含任意字符
2.引号可省略
3.就算引号省略了，键名也还是字符串(重要)
4.Object.keys(obj)可以得到obj的所有key
</code></pre><p><font color=red>变量作属性名</font></p>
<pre><code>let p1 = &quot;name&quot;;
let obj = {p1 : 'chengjian'} 这样写，属性名为'p1'
let obj = {[p1] : 'chengjian'} 这样写，属性名为'name'

1.不加[]的属性名会自动变成字符串
2.加了[]则会当做变量求值
3.值如果不是字符串，则会自动变成字符串
</code></pre><h3 id="font-color2对象增删改查font"><font color>2.对象增删改查</font></h3>
<p><font color=red>删除</font></p>
<pre><code>  let obj = {
      a : chengjian
  }
  console.log('xxx' in obj)

  1.不含属性名
    'a' in obj

  2.含有属性名，但是值为undefined
    'a' in obj &amp;&amp; obj.a === undefined
</code></pre><ol>
<li>delete obj.xxx 或 delete obj[&lsquo;xxx&rsquo;] 即可删除 obj 的 xxx 属性</li>
<li>&lsquo;xxx&rsquo; in window 可以判断该属性是否存在该对象里面，返回 true | false，无法区自身和公有属性</li>
</ol>
<p><font color=red>查</font></p>
<pre><code>1.查看自身所有属性
Object.keys(obj)

2.查看自身所有值
Object.values(obj)

3.查看自身属性和值
Object.entries(obj)

3.判断一个属性是否是自身属性
let obj = {
    'name' : 'chengjian',
    'age' : 18
}
obj.hasOwnProperty('name')

4.instanceof 判断它是否是谁谁谁的实例
let obj = {};
obj instanceof Object;

</code></pre><p><font color=red>修改或增加属性(写属性)</font></p>
<pre><code>1.Object.assign(赋值的对象，赋值内容[对象形式写出])
let obj = {}
Object.assign(obj,{p1:1,p2:2,p3:3})

2.Object.create() 创建一个新对象，使用现有的对象来提供新创建对象的__proto__
let person = {
    onOff : true,
    show : function(){
      console.log('My name is YaoChengjian');
    }
}
let me = Object.create(person)
</code></pre>]]></content>
        </item>
        
        <item>
            <title>20 - [JS全解]JS对象分类</title>
            <link>http://yaochengjian.com/posts/20/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0820</pubDate>
            
            <guid>http://yaochengjian.com/posts/20/</guid>
            <description>1.堆内存与栈内存  let squareList = [];let widthList = [5,6,5,6,5,6]let squarePrototype = {getArea(){return this.width * this.width;}getLength(){return this.width * 4}}for(let i = 0;i &amp;lt; 12;i++&amp;gt;){squareList[i] = Object.create(squarePrototype);squareList[i].width = widthList[i]}2.new 关键字 大小写
1.所有构造函数(专门用于创建对象的函数)首字母大写
2.所有被构造出来的对象，首字母小写
 function Square(width){this.width = width;}Square.prototype.getArea = function(){return this.width * this.width;}Square.prototype.getLength = function(){return this.width * 4}let square = new Square(5);square.</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1堆内存与栈内存font"><font color=red>1.堆内存与栈内存</font></h3>
<pre><code>    let squareList = [];
    let widthList = [5,6,5,6,5,6]
    let squarePrototype = {
        getArea(){
            return this.width * this.width;
        }
        getLength(){
            return this.width * 4
        }
    }
    for(let i = 0;i &lt; 12;i++&gt;){
        squareList[i] = Object.create(squarePrototype);
        squareList[i].width = widthList[i]
    }
</code></pre><p><img src="../../images/%E5%86%85%E5%AD%98.png" alt=""></p>
<h3 id="font-colorred2new-关键字font"><font color=red>2.new 关键字</font></h3>
<p><font color=red>大小写</font><br>
1.所有构造函数(专门用于创建对象的函数)首字母大写<br>
2.所有被构造出来的对象，首字母小写</p>
<pre><code>    function Square(width){
        this.width = width;
    }
    Square.prototype.getArea = function(){
        return this.width * this.width;
    }
    Square.prototype.getLength = function(){
        return this.width * 4
    }
    let square = new Square(5);
    square.width;
    square.getArea();
    square.getLength();

    总结：new Fn()自动做了四件事情
    1.自动创建空对象
    2.自动为空对象关联原型，原型地址指定为Fn.prototype
    3.自动将空对象作为this关键字运行构造函数
    4.自动return this
</code></pre><h3 id="font-colorred3如何确定一个对象的原型font"><font color=red>3.如何确定一个对象的原型</font></h3>
<pre><code>为什么?
    1.let obj = new Object() 的原型是Object.prototype
    2.let arr = new Array() 的原型是Array.prototype
    3.let square = new Square() 的原型是Square.prototype
    4.let fn = new Function() 的原型是Function.prototype
因为new操作故意这么做
    1.自动创建空对象
    2.自动为空对象关联原型，原型地址指定为X.prototype
    3.自动将空对象作为this关键字运行构造函数
    4.自动return this
结论
    你是谁构造的，你的原型就是谁的prototype属性对象的对象
</code></pre><h3 id="font-colorred4类型-vs-类font"><font color=red>4.类型 V.S 类</font></h3>
<p><font color=red>类型</font></p>
<ol>
<li>类型是 JS 数据的分类，有七种</li>
<li>四基两空一对象</li>
</ol>
<p><font color=red>类</font></p>
<ol>
<li>类是针对于对象的分类，有无数种</li>
<li>常见的有 Array、Function、Date、RegExp 等</li>
</ol>
<pre><code>1.定义一个数组
    let arr = [1,2,3]
    let arr = new Array(1,2,3) 元素为1,2,3
    let arr = new Array(3) 长度为3

2.数组对象的自身属性
    'length'
    注意，属性名没有数字，只有字符串

3.JS终极一问
    a : window是谁构造的? 可以通过constructor属性看出构造者是谁
    b : window.Object 是谁构造的? 所有函数都是window.Funtion构造的
    c : window.Function是谁构造的?
            1.所有函数都是window.Function 构造的
            2.浏览器构造了Function,然后指定它的构造者是自己
</code></pre><h3 id="font-colorred5class-语法font"><font color=red>5.class 语法</font></h3>
<pre><code>    class Rectangle{
        constructor(height,width){
            this.height = height;
            this.width = width;
        }
        get area(){
            return this.calcArea();
        }
        calcArea(){
            return this.height * this.width;
        }
    }

    let square = new Rectangle(10,10);

    1.一个类只能拥有一个名为'construction'的特殊方法
</code></pre>]]></content>
        </item>
        
        <item>
            <title>21 - [JS全解]JS对象继承</title>
            <link>http://yaochengjian.com/posts/21/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0821</pubDate>
            
            <guid>http://yaochengjian.com/posts/21/</guid>
            <description>1.继承(子类继承父类的属性和方法) 1.原型继承
2.call 继承
3.寄生组合继承
4.Es6 中 class 类实现继承
1.原型继承
a. 方式 : Son.prototype = new Person(),Person 的实例本身具备父类 Person 的私有属性和公有方法,子类 Son 的原型指向它,那么子类 B 的实例就可以找到这些属性方法了
b. 和传统后台语言的继承不一样,子类继承父类,并不是把父类的属性方法客隆一份给子类(这样处理子类和父类就没直接关系了),JS 中的原型继承是让子类和父类建立原型链接的机制,子类的实例调取父类原型上的方法,都是基于原型链的查找机制完成的 存在的问题 : 子类可以重写父类原型上的方法(重写),子类和父类还有关系的 Son.prototype.__proto__.getX = null 把父类 Person 原型上的 getX 重写为 null,Person 的其它实例也会受到影响
原型继承存在的问题:
1.父类实例私有的属性以及公有的属性都变为了子类实例的公有属性
2.如果子类 Son 的原型上之前有属性方法,之前的方法都没有了
=&amp;gt; 原型继承 : 让子类的原型指向父类的一个实例function Person(){this.name = &#39;chengjian&#39;;}Person.prototype = {constructor : A,getX : function(){console.log(this.x);}}function Son(){this.age = 18;}Son.</description>
            <content type="html"><![CDATA[<h3 id="1继承子类继承父类的属性和方法">1.继承(子类继承父类的属性和方法)</h3>
<p>1.原型继承<br>
2.call 继承<br>
3.寄生组合继承<br>
4.Es6 中 class 类实现继承</p>
<p><font color=red>1.原型继承</font></p>
<p>a. 方式 : Son.prototype = new Person(),Person 的实例本身具备父类 Person 的私有属性和公有方法,子类 Son 的原型指向它,那么子类 B 的实例就可以找到这些属性方法了</p>
<p>b. 和传统后台语言的继承不一样,子类继承父类,并不是把父类的属性方法客隆一份给子类(这样处理子类和父类就没直接关系了),JS 中的原型继承是让子类和父类建立原型链接的机制,子类的实例调取父类原型上的方法,都是基于原型链的查找机制完成的 <font color=red>存在的问题 : 子类可以重写父类原型上的方法(重写),子类和父类还有关系的</font> Son.prototype.__proto__.getX = null <font color=red>把父类 Person 原型上的 getX 重写为 null,Person 的其它实例也会受到影响</font></p>
<p><font color=red>原型继承存在的问题:</font><br>
1.父类实例私有的属性以及公有的属性都变为了子类实例的公有属性<br>
2.如果子类 Son 的原型上之前有属性方法,之前的方法都没有了</p>
<pre><code>=&gt; 原型继承 : 让子类的原型指向父类的一个实例

function Person(){
    this.name = 'chengjian';
}
Person.prototype = {
    constructor : A,
    getX : function(){
        console.log(this.x);
    }
}

function Son(){
    this.age = 18;
}
Son.prototype = new Person();

let s = new Son();

</code></pre><p><font color=red>2.call 继承</font><br>
a. call 继承:把父类 Person 作为普通函数执行,让 Person 中 this 变成 Son 的实例,相当于给 Son 的实例增加一些属性和方法<br>
b. <font color=red>弊端:把父类 Person 当做普通函数执行,和父类原型没什么关系了,仅仅是把 Person 中的私有属性变为子类 Son 实例的私有属性而已,Person 原型上的公有属性方法和 Son 及它的实例没什么关系</font></p>
<pre><code>function Person(name){
    this.name = name;
}
Person.prototype.say = function(){
    console.log(this.name);
}

function Son(age,name){
    Person.call(this,name); // call继承,把Person执行,让Person中的this变成Son的实例
    this.age = age;
}
let s = new Son(18,'chengjian');
</code></pre><p><font color=red>3.寄生组合继承 : Person 的私有变为 Son 的私有,Person 的公有变为 Son 的公有</font></p>
<pre><code>Object.create : 内置Object类天生自带的方法
    1.创建一个空对象
    2.让这个空对象__proto__指向传递进来的对象(传递进来的对象作为你空对象的原型)

function Person(name){
    this.name = name;
}
Person.prototype.say = function(){
    console.log(`my name is ${this.name}`);
}
function Son(age,name){
    Person.call(this,name);  // 基于call把Person的私有变为Son的私有
    this.age = age;
}
Son.prototype = Person.prototype; // 一般不这样写,这样写可以轻易修改父类的东西,这样会导致Person的其它实例也会受到影响

Son.prototype = Object.create(Person.prototype);

let s = new Son(18,'chengjian');
</code></pre><p><font color=red>4.Es6 中 class 类实现继承</font></p>
<pre><code>1.ES6创建类是有自己标准语法(这种语法创建出来的类只能new执行,不能当做普通函数执行)

class Person{ // Person是类名,没有小括号
    constructor(name,age){
        // 等价于传统ES5类的构造体
        this.name = name;
        this.age = age;
    }

    // 给Person原型上设置方法(只能设置方法不能设置属性)
    say(name){
        console.log(name);
    }

    // 把Person当做一个普通对象设置私有方法(等价于Person.sayAge = function(){})
    static sayAge(){
        console.log(this.age);
    }
}

class Son extends Person{
    constructor(sex,name,age){
        super(name,age);  // super 等等于 call 继承 私有属性
        this.sex = sex;
    }
}

let s = new Son('男');
</code></pre>]]></content>
        </item>
        
        <item>
            <title>22 - [JS全解]JS数组</title>
            <link>http://yaochengjian.com/posts/22/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0822</pubDate>
            
            <guid>http://yaochengjian.com/posts/22/</guid>
            <description>1.JS 数组 1.创建一个数组let arr = [1,2,3];let arr = new Array(1,2,3);let arr = new Array(3) 只有一个参数时候length长度为32.转化let arr = &#39;1,2,3&#39;.split(&#39;,&#39;) 以逗号为分割成为一个数组let arr = &#39;123&#39;.split(&#39;&#39;) 以空字符串形式分割成为一个数组let arr = Array.from(&#39;abc&#39;) 需要满足(是否有下标，是否有length属性)有就可以尝试变成数组3.把伪数组变成数组let divs = document.getElementsByTagName(&#39;div&#39;);let arrDiv = Array.from(divs);console.log(arrDiv);4.concat()合并数组let arr1 = [1,2,3];let arr2 = [4,5,6];arr.concat(arr2); 得出来是新的一个数组，不会改变原来数组5.slice()截取数组let arr1 = [1,2,3,4,5,6];let arr2 = arr.slice(2); =&amp;gt; [3,4,5,6] 会得到一个新的数组，不会改变原来数组let arr3 = arr.</description>
            <content type="html"><![CDATA[<h3 id="font-colorred1js-数组font"><font color=red>1.JS 数组</font></h3>
<pre><code>1.创建一个数组
    let arr = [1,2,3];
    let arr = new Array(1,2,3);
    let arr = new Array(3) 只有一个参数时候length长度为3

2.转化
    let arr = '1,2,3'.split(',') 以逗号为分割成为一个数组
    let arr = '123'.split('') 以空字符串形式分割成为一个数组
    let arr = Array.from('abc') 需要满足(是否有下标，是否有length属性)有就可以尝试变成数组

3.把伪数组变成数组
    let divs = document.getElementsByTagName('div');
    let arrDiv = Array.from(divs);
    console.log(arrDiv);

4.concat()合并数组
    let arr1 = [1,2,3];
    let arr2 = [4,5,6];
    arr.concat(arr2); 得出来是新的一个数组，不会改变原来数组

5.slice()截取数组
    let arr1 = [1,2,3,4,5,6];
    let arr2 = arr.slice(2); =&gt; [3,4,5,6] 会得到一个新的数组，不会改变原来数组
    let arr3 = arr.slice(0); =&gt; 截取真个数组
    let arr4 = arr.slice(2,5) =&gt; [3,4,5] 从索引0到索引5(不包括索引5)
</code></pre><h3 id="font-colorred2数组的增删改查修改原数组font"><font color=red>2.数组的增删改查(修改原数组)</font></h3>
<pre><code>1.删除头部元素
    arr.shift() arr被修改，并返回被删元素

2.删除尾部元素
    arr.pop() arr被修改，并返回被删元素

3.删除部分内容(arr会被修改)
    arr.splice(index,num) index从第几个开始，num删除多少个
    arr.splice(idnex,num,x,y) index从第几个开始，num删除多少个，添加x,y上去
</code></pre><h3 id="font-colorred3查看所有元素font"><font color=red>3.查看所有元素</font></h3>
<pre><code>   let arr = [1,2,3,4,5];
       arr.x = 'xxx';
1.查看所有属性名
        Object.keys(arr);
        for(let key in arr){
            console.log(`${key} : ${arr[key]}`)
        }

2.查看数字属性名和值
        for(let i = 0;i &lt; arr.length;i++){
                console.log(`${i} : ${arr[i]}`)
        }

        arr.forEach(function(key,value){
                console.log(`${key} : ${value}`)
        })

3.查找某个元素是否在数组里
        arr.indexOf(3); 存在返回索引，不存在返回-1

4.使用条件查找元素
        arr.find(function(x){   find元素找到满足条件的即停止,返回那个值
            return x % 2 === 0
        });

5.使用条件查找元素的索引
        arr.findIndex(function(x){  findIndex元素找到满足条件的即停止，返回索引
            return x % 2 === 0
        })
</code></pre><h3 id="font-colorred4增加数组中的元素修改原数组font"><font color=red>4.增加数组中的元素(修改原数组)</font></h3>
<pre><code>    let arr = [1,2,3,4,5];
1.在尾部加元素
    arr.push(newItem) 修改arr,返回新长度
    arr.push(item1,item2)

2.在头部加元素
    arr.unshift(newItem) 修改arr,返回新长度
    arr.unshift(item1,item2)
</code></pre><h3 id="font-colorred5数组中排序修改原数组font"><font color=red>5.数组中排序(修改原数组)</font></h3>
<pre><code>    let arr = [{name:'发条魔灵',score:98},
               {name:'疾风亚索',score:94},
               {name:'寒冰射手',score:91}];

        1.a减b的值是正数则是从小到大排序，负数则从大到小排序
        2.a和b是arr里面随机一项，一直会比较完

        arr.sort(function(a,b){
            return a.score - b.score;
        });
</code></pre><h3 id="font-colorred6font"><font color=red>6.</font></h3>
<pre><code>    let arr = [1,2,3,4,5,6];

1.map()方法创建一个新数组，其结果是该数组中的每一个元素都调用一个提供函数后返回结果
        arr.map(function(item,index,arr){
            return item * item
        });

2.filter()方法，是true就返回，否则就筛选掉
        arr.filter(function(item,index,arr){
            return item % 2 === 0;
        });

3.reduce()方法
        1.initial代表初始值(可以设置任意自己想要的数据类型)
        2.item是数组中的值，从下标0开始
        arr.reduce(function(initial,item){
                return  &quot;自己想要的东西&quot;
        },initial);

        案例1
        arr.reduce(function(sum,item){
                return sum+item
        },0)

        案例2
        arr.reduce(function(result,item){
                return result.concat(item*item);
        },[]);
</code></pre><pre><code>  面试题
  let arr = [
    { 名称: &quot;动物&quot;, id: 1, parent: null },
    { 名称: &quot;狗&quot;, id: 2, parent: 1 },
    { 名称: &quot;猫&quot;, id: 3, parent: 1 }
  ];

  变成
    {
    id : 1,
    名称 : '动物',
    children : [
    {id:2,名称:'狗',children:null},
    {id:3,名称:'猫',children:null}
    ]
    }
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>22-1 - [JS全解]Map 、 Set</title>
            <link>http://yaochengjian.com/posts/22-1/</link>
            <pubDate>Wed, 25 Dec 2019 21:55:11 +0823</pubDate>
            
            <guid>http://yaochengjian.com/posts/22-1/</guid>
            <description>1.Map([iterable]) 键值对为两个元素的数组例如:[1,&amp;lsquo;one&amp;rsquo;] 1.map 的实例属性和操作方法
&amp;mdash;-size : 返回成员总数
&amp;mdash;-set(key,value) : 添加新的键值
&amp;mdash;-has(key) : 是否有某个键
&amp;mdash;-get(key) : 读取某个对应的值
&amp;mdash;-delete(key) : 删除某个键
&amp;mdash;-clear() : 清空
2.map 实例遍历的方法
&amp;mdash;-keys() : 返回键名
&amp;mdash;-values() : 返回键值
&amp;mdash;-entires() : 返回键值对
&amp;mdash;-forEach() : 遍历所有成员
利用map实现去重let array = [1,2,3,5,1,2,3,4]let map = new Map();for(let i = 0;i &amp;lt; array.length;i++&amp;gt;){if(map.has(array[i])){continue;}else{map.set(array[i],true);}}let newAry = [...map.keys()]2.Set([iterable])对象允许你存储任何类型的唯一值(set 里面的值是唯一的) 方法和属性
&amp;mdash;-size : 返回 set 对象的个数</description>
            <content type="html"><![CDATA[<h3 id="1mapiterable-键值对为两个元素的数组例如1one">1.Map([iterable]) 键值对为两个元素的数组例如:[1,&lsquo;one&rsquo;]</h3>
<p><font color=red>1.map 的实例属性和操作方法</font><br>
&mdash;-size : 返回成员总数<br>
&mdash;-set(key,value) : 添加新的键值<br>
&mdash;-has(key) : 是否有某个键<br>
&mdash;-get(key) : 读取某个对应的值<br>
&mdash;-delete(key) : 删除某个键<br>
&mdash;-clear() : 清空</p>
<p><font color=red>2.map 实例遍历的方法</font><br>
&mdash;-keys() : 返回键名<br>
&mdash;-values() : 返回键值<br>
&mdash;-entires() : 返回键值对<br>
&mdash;-forEach() : 遍历所有成员</p>
<pre><code>利用map实现去重
    let array = [1,2,3,5,1,2,3,4]
    let map = new Map();
    for(let i = 0;i &lt; array.length;i++&gt;){
        if(map.has(array[i])){
            continue;
        }else{
            map.set(array[i],true);
        }
    }
    let newAry = [...map.keys()]
</code></pre><h3 id="2setiterable对象允许你存储任何类型的唯一值set-里面的值是唯一的">2.Set([iterable])对象允许你存储任何类型的唯一值(set 里面的值是唯一的)</h3>
<p><font color=red>方法和属性</font><br>
&mdash;-size : 返回 set 对象的个数<br>
&mdash;-add(value) : 在 set 对象尾部添加一个元素,返回该 set 对象<br>
&mdash;-clear() : 移除 set 对象内的所有元素
&mdash;-delete(value) : 移除 set 中与这个值相等的元素<br>
&mdash;-has(value) : 判断 set 中是否存在这个值
&mdash;-entires() : 返回键值对的数组(二维数组)<br>
&mdash;-keys() : 返回键名<br>
&mdash;-values() : 返回键值<br>
&mdash;-entires() : 返回键值对<br>
&mdash;-forEach() : 遍历所有成员</p>
]]></content>
        </item>
        
        <item>
            <title>1000 - 变量提升、闭包</title>
            <link>http://yaochengjian.com/posts/1000/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>http://yaochengjian.com/posts/1000/</guid>
            <description>1.一般都把 js 放到 body 的末尾 a:为什么？
b:放在 head 中可以不可以？如何放到 head 中也可以实现出放到 body 末尾的效果？
c:script 标签中有两个属性：defer / async,这两个属性是做什么的？
2.js 数据渲染机制及堆栈内存 a:基本类型(因为数据简单，之间在全局作用域开辟一个地址存储)
&amp;lt;!--1.变量提升(找var和函数(var开始定义是undefined、函数定义赋值是同时完成的))--&amp;gt;var a = 12;var b = a;b = 13;console.log(a);b:引用类型(因为数据复杂，所以会开辟一个堆内存来存储)
var ary1 = [12,23];var ary2 = ary1;ary2.push(100);console.log(ary1);A:栈内存:作用域
1.提供一个供 js 代码自上而下执行的环境(代码都是在栈内存中执行的)
2.由于基本数据类型比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存进去的
=&amp;gt;当栈内存被销毁，存储的那些基本值也都跟着销毁了
B:堆内存:引用值对应的空间
1.存储引用类型值(对象:键值对 函数:代码字符串)
=&amp;gt;当前堆内存稀释被销毁，那么这个引用值彻底没了
=&amp;gt;堆内存的释放：当堆内存没有被任何变量或者其它东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的堆内存销毁掉
=&amp;gt;xxx = null 通过空对象指针 null 可以让原始变量(或者其它东西)谁都不指向，那么原有被占用内存就没有被东西占用了，浏览器就会销毁它</description>
            <content type="html"><![CDATA[<h3 id="1一般都把-js-放到-body-的末尾">1.一般都把 js 放到 body 的末尾</h3>
<p>a:为什么？<br>
b:放在 head 中可以不可以？如何放到 head 中也可以实现出放到 body 末尾的效果？<br>
c:script 标签中有两个属性：defer / async,这两个属性是做什么的？</p>
<h3 id="2js-数据渲染机制及堆栈内存">2.js 数据渲染机制及堆栈内存</h3>
<p>a:基本类型(因为数据简单，之间在全局作用域开辟一个地址存储)</p>
<pre><code>&lt;!--
1.变量提升(找var和函数(var开始定义是undefined、函数定义赋值是同时完成的))
--&gt;
var a = 12;
var b = a;
b = 13;
console.log(a);
</code></pre><p><img src="../../images/js-1.png" alt=""></p>
<p>b:引用类型(因为数据复杂，所以会开辟一个堆内存来存储)</p>
<pre><code>var ary1 = [12,23];
var ary2 = ary1;
ary2.push(100);
console.log(ary1);
</code></pre><p><img src="../../images/js2.png" alt=""></p>
<p>A:栈内存:作用域<br>
1.提供一个供 js 代码自上而下执行的环境(代码都是在栈内存中执行的)<br>
2.由于基本数据类型比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存进去的<br>
    =&gt;当栈内存被销毁，存储的那些基本值也都跟着销毁了</p>
<p>B:堆内存:引用值对应的空间<br>
1.存储引用类型值(对象:键值对 函数:代码字符串)<br>
=&gt;当前堆内存稀释被销毁，那么这个引用值彻底没了<br>
=&gt;堆内存的释放：当堆内存没有被任何变量或者其它东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的堆内存销毁掉<br>
=&gt;xxx = null 通过空对象指针 null 可以让原始变量(或者其它东西)谁都不指向，那么原有被占用内存就没有被东西占用了，浏览器就会销毁它</p>
]]></content>
        </item>
        
    </channel>
</rss>
