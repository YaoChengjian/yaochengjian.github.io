<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="1.es6 中的 getter 和 setter getter:取值函数,不用再函数后面加括号就能拿到函数里面的值
 let obj = {surname : &amp;quot;yao&amp;quot;,name : &amp;quot;chengjian&amp;quot;,get surnameName(){return &amp;quot;姓名&amp;quot; &#43; &amp;quot;---&amp;quot; &#43; this.surname &#43; this.name;}}console.log(obj.surnameName); // obj.surnameName方式调用即可setter:设置函数,通过设置对象方式来设置属性里面的值
 let obj = {surname : &amp;quot;yao&amp;quot;,name : &amp;quot;chengjian&amp;quot;,set surnameName(xxx){console.log(xxx);}}obj.surnameName = &amp;quot;你好&amp;quot; //通过set方式来设置值2.computed 计算属性  类型 : { [key: string]: Function | {get: Function, set: Function} } 详细 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的this上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性性使用箭头函数，则this不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。 示例：   let vm = new Vue({el: &amp;quot;app&amp;quot;,data(){return {a: 2}},computed: {aDouble: vm =&amp;gt; vm." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://yaochengjian.com/posts/41/" />


    <title>
        
            41 - computed和watch :: 姚 成 健 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.5dcefbf8102eb536dd3e2de53ffebfa58599ab2435c241a0db81728a5e015f2e.css">




<meta itemprop="name" content="41 - computed和watch">
<meta itemprop="description" content="1.es6 中的 getter 和 setter getter:取值函数,不用再函数后面加括号就能拿到函数里面的值
 let obj = {surname : &quot;yao&quot;,name : &quot;chengjian&quot;,get surnameName(){return &quot;姓名&quot; &#43; &quot;---&quot; &#43; this.surname &#43; this.name;}}console.log(obj.surnameName); // obj.surnameName方式调用即可setter:设置函数,通过设置对象方式来设置属性里面的值
 let obj = {surname : &quot;yao&quot;,name : &quot;chengjian&quot;,set surnameName(xxx){console.log(xxx);}}obj.surnameName = &quot;你好&quot; //通过set方式来设置值2.computed 计算属性  类型 : { [key: string]: Function | {get: Function, set: Function} } 详细 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的this上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性性使用箭头函数，则this不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。 示例：   let vm = new Vue({el: &quot;app&quot;,data(){return {a: 2}},computed: {aDouble: vm =&gt; vm.">
<meta itemprop="datePublished" content="2020-02-17T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-02-17T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="586">
<meta itemprop="image" content="http://yaochengjian.com/"/>



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://yaochengjian.com/"/>

<meta name="twitter:title" content="41 - computed和watch"/>
<meta name="twitter:description" content="1.es6 中的 getter 和 setter getter:取值函数,不用再函数后面加括号就能拿到函数里面的值
 let obj = {surname : &quot;yao&quot;,name : &quot;chengjian&quot;,get surnameName(){return &quot;姓名&quot; &#43; &quot;---&quot; &#43; this.surname &#43; this.name;}}console.log(obj.surnameName); // obj.surnameName方式调用即可setter:设置函数,通过设置对象方式来设置属性里面的值
 let obj = {surname : &quot;yao&quot;,name : &quot;chengjian&quot;,set surnameName(xxx){console.log(xxx);}}obj.surnameName = &quot;你好&quot; //通过set方式来设置值2.computed 计算属性  类型 : { [key: string]: Function | {get: Function, set: Function} } 详细 计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的this上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性性使用箭头函数，则this不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。 示例：   let vm = new Vue({el: &quot;app&quot;,data(){return {a: 2}},computed: {aDouble: vm =&gt; vm."/>





    <meta property="article:published_time" content="2020-02-17 00:00:00 &#43;0000 UTC" />








    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">Yao Chengjian</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="http://yaochengjian.com/posts">博客</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>3 minutes

            

            </p>
        </div>

        <article>
            <h1 class="post-title">
                <a href="http://yaochengjian.com/posts/41/">41 - computed和watch</a>
            </h1>

            

            <div class="post-content">
                <h3 id="1es6-中的-getter-和-setter">1.es6 中的 getter 和 setter</h3>
<p>getter:取值函数,不用再函数后面加括号就能拿到函数里面的值</p>
<pre><code>    let obj = {
        surname : &quot;yao&quot;,
        name : &quot;chengjian&quot;,
        get surnameName(){
            return &quot;姓名&quot; + &quot;---&quot; + this.surname + this.name;
        }
    }
    console.log(obj.surnameName); // obj.surnameName方式调用即可
</code></pre><p>setter:设置函数,通过设置对象方式来设置属性里面的值</p>
<pre><code>    let obj = {
        surname : &quot;yao&quot;,
        name : &quot;chengjian&quot;,
        set surnameName(xxx){
            console.log(xxx);
        }
    }
    obj.surnameName = &quot;你好&quot; //通过set方式来设置值
</code></pre><h3 id="2computed-计算属性">2.computed 计算属性</h3>
<ul>
<li>类型 : <code style="color:red">{ [key: string]: Function | {get: Function, set: Function} }</code></li>
<li>详细
计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的<code style="color:red">this</code>上下文自动地绑定为 Vue 实例。注意如果你为一个计算属性性使用箭头函数，则<code style="color:red">this</code>不会指向这个组件的实例，不过你仍然可以将其<code style="color:red">实例</code>作为函数的第一个参数来访问。</li>
<li><b>示例</b>：</li>
</ul>
<pre><code>    let vm = new Vue({
        el: &quot;app&quot;,
        data(){
            return {
                a: 2
            }
        },
        computed: {
            aDouble: vm =&gt; vm.a * 2
        },
        template: `
            &lt;div&gt;
                {{aDouble}}
            &lt;/div&gt;
        `
    });
</code></pre><p>计算属性的结果被缓存，除非依赖的响应式属性变化才会重新计算。注意，如果某个依赖(比如非响应式属性)在该实例范畴之外，则计算属性是不会被更新的。</p>
<ul>
<li><b>示例</b>：</li>
</ul>
<pre><code>  let vm = new Vue({
      data(){
          return {
              a : 1
          }
      },
      computed: {
          //仅读取
          aDouble: function(){
              return this.a * 2;
          },

          //读取和设置
          aPlus: {
              get: function(){
                  return this.a + 1;
              },
              set: function(){
                  this.a = v - 1;
              }
          }
      }
  });

  vm.aPlus    // =&gt; 2
  vm.aPlus = 3;
  vm.a        // =&gt; 2
  vm.aDouble  // =&gt; 4
</code></pre><ul>
<li><b>computed 显示案例</b>：</li>
</ul>
<pre><code>  &lt;template&gt;
&lt;div&gt;
  &lt;button @click=&quot;changeGender('')&quot;&gt;全部&lt;/button&gt;
  &lt;button @click=&quot;changeGender('男')&quot;&gt;男&lt;/button&gt;
  &lt;button @click=&quot;changeGender('女')&quot;&gt;女&lt;/button&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;(item,key) in displayName&quot;&gt;{{item.name}}--{{item.sex}}&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
let createUser = (name, age, sex) =&gt; {
return { name, age, sex };
};
export default {
data() {
  return {
    users: [
      createUser(&quot;frank&quot;, 18, &quot;男&quot;),
      createUser(&quot;lucy&quot;, 20, &quot;女&quot;),
      createUser(&quot;tom&quot;, 19, &quot;男&quot;),
      createUser(&quot;sady&quot;, 16, &quot;女&quot;)
    ],
    gender: &quot;&quot;
  };
},
computed: {
  displayName() {
    let gender = this.gender;
    let users = this.users;
    let genderObj = {
      man: &quot;男&quot;,
      women: &quot;女&quot;
    };

    if (gender === &quot;&quot;) {
      return users;
    } else {
      return users.filter(item =&gt; {
        return item.sex === genderObj[gender];
      });
    }
  }
},
methods: {
  changeGender(string) {
    if (string) {
      string = string === &quot;男&quot; ? &quot;man&quot; : &quot;women&quot;;
    }
    this.gender = string;
  }
}
};
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre><ul>
<li>computed 用来监控自己定义的变量，该变量不在 data 里面声明，直接在 computed 里面定义，然后就可以在页面上进行双向数据绑定展示出结果或者用作其他处理。</li>
<li><code style="color:red">比较适合对多个变量或者对象进行处理后返回一个结果值</code>，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，举例：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或增多曾少或者删除商品，总金额都应该发生变化。这里的这个总金额使用 computed 属性来进行计算是最好的选择。</li>
</ul>
<h3 id="3watch监控-data-里面数据变化">3.watch(监控 data 里面数据变化)</h3>
<ul>
<li>类型：<code style="color:red">{ [key: string]: string | Function | Object | Array }</code></li>
<li>详细：<br>
一个对象，键是需要观测的表达式，值是对应的回调函数。值也可以是方法名，或者包含选项的对象。<br>
watch 主要用于监控 vue 实例的变化，他监控的变量必须在 data 里面声明才可以，它可以监控一个变量，也可以监控一个对象。</li>
<li>示例</li>
</ul>
<pre><code>    &lt;template&gt;
        &lt;div&gt;
            {{n}}
            &lt;br/&gt;
            &lt;button @click=&quot;add1&quot;&gt;+1&lt;/button&gt;
            &lt;button @click=&quot;add2&quot;&gt;+2&lt;/button&gt;
            &lt;button @click=&quot;minus1&quot;&gt;-1&lt;/button&gt;
            &lt;button @click=&quot;minus2&quot;&gt;-2&lt;/button&gt;
            &lt;br/&gt;
            &lt;button @click=&quot;undo&quot;&gt;&lt;/button&gt;
            &lt;br/&gt;
            {{history}}
        &lt;/div&gt;
    &lt;/template&gt;

    &lt;script&gt;
        export default {
            data(){
                return {
                    n: 0,
                    history: [],
                    isUndoMode: false
                }
            },
            methods:{
                add1(){ this.n += 1 },
                add2(){ this.n += 2 },
                minus(){ this.n -= 1 },
                minus(){ this.n -= 2 }
            },
            watch: {  // watch是异步操作
                n(newV,oldV){ // newV是n数据更新后的新值,oldV是n数据未更新的旧值
                    if(!this.isUndoMode){
                        this.history.push({ form : newV,to : oldV });
                    }
                }
            },
            undo(){
                const last = this.history.pop();
                const old = last.from;
                this.isUndoMode = true;
                this.n = old;   // 一更新n的值马上又会触发n的函数
                this.$nextTick(()=&gt;{
                    this.isUndoMode = false;
                },0);
            }
        }
    &lt;/script&gt;

    &lt;style scoped&gt;&lt;/style&gt;
</code></pre><ul>
<li>handler 和 immediate 用法<br>
<code style="color:red">immediate: true 第一次是否要执行</code></li>
</ul>
<pre><code>    &lt;template&gt;
        &lt;div&gt;{{n}}&lt;/div&gt;
    &lt;/tempalte&gt;

    &lt;script&gt;
        export default{
            data(){
                return {
                    n: 0
                }
            },
            watch: {
                n: {
                    handler(){
                        this.n = &quot;一开始就监听数据,并且执行这里的内容&quot;
                    }，
                    immediate: true  // 第一次是否要执行
                }
            }
        }
    &lt;/script&gt;

    &lt;style scoped&gt;&lt;/style&gt;
</code></pre><ul>
<li>何为 data 数据变化<br>
<code style="color:red">简单类型看值,引用类型看地址</code><br>
<code style="color:red">deep: true 引用类型里面属性的值变了也会触发 obj 变了</code></li>
</ul>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;button @click=&quot;obj={a:'a'}&quot;&gt;obj&lt;/button&gt;

    // 引用类型里面属性的值变了也会触发obj变了
    &lt;button @click=&quot;obj.a = 'a+1'&quot;&gt;obj.a&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      obj: {
        a: &quot;a&quot;
      }
    };
  },
  watch: {
    obj: {
      handler(newV, oldV) {
        console.log(`obj内存地址变了,以前的是${oldV},旧的是${newV}`);
      },
      deep: true  // 引用类型里面属性的值变了也会触发obj变了
    }
  }
};
&lt;/script&gt;

&lt;style&gt;&lt;/style&gt;
</code></pre><ul>
<li>watch 语法完整用法</li>
</ul>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        {{n}}
        &lt;button @click=&quot;add1&quot;&gt;+1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default{
        data(){
            return{
                n: 0,
                obj: {
                    a: 0
                }
            }
        },
        methods:{
            add1(){
                this.n += 1;
            },
            logN(){
                console.log(this.n);
            }
        },
        watch:{
            n(){} // 可以是函数
            n: 'logN' // 可以是methods里面的函数
            n: { handle(){} , deep:true }
            n: { handle(){} , immediate:true }
            n: [f1(){},f2(){}] //都会执行里面的函数
            'obj.a'(){} // 监听obj里面a的值是否变化
        }
    }
&lt;/script&gt;

&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
            </div>
        </article>

        <hr />

        <div class="post-info">

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>586 Words</p>

            <p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2020-02-17 08:00 &#43;0800</p>
        </div>

        
            <div class="pagination">
                <div class="pagination__title">
                    <span class="pagination__title-h">Read other posts</span>
                    <hr />
                </div>

                <div class="pagination__buttons">
                    
                        <span class="button previous">
                            <a href="http://yaochengjian.com/posts/40/">
                                <span class="button__icon">←</span>
                                <span class="button__text">40 - vue全解(起手式1)</span>
                            </a>
                        </span>
                    

                    
                        <span class="button next">
                            <a href="http://yaochengjian.com/posts/42/">
                                <span class="button__text">42 - vue全解(模板、指令与修饰符)</span>
                                <span class="button__icon">→</span>
                            </a>
                        </span>
                    
                </div>
            </div>
        

        
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
            <span></span>
            <span> <a href="http://yaochengjian.com/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            <span>Made with &#10084; by <a href="https://github.com/rhazdon">rhazdon</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
