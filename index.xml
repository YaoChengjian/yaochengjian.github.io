<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>姚 成 健</title>
    <link>http://yaochengjian.com/</link>
    <description>Recent content on 姚 成 健</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-hans</language>
    <lastBuildDate>Fri, 06 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://yaochengjian.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>23 - [JS全解]JS函数</title>
      <link>http://yaochengjian.com/posts/23/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/23/</guid>
      <description>1.四种方式定义函数 1.定义一个函数
具名函数(具有名字的函数)function 函数名(形式参数1,形式参数2){语句return 返回值}匿名函数上面的具名函数,去掉函数就是匿名函数箭头函数如果只有一个形参,可以省略括号,箭头后面只有一句话默认是(return x + x)fn = x =&amp;gt; x+x;否则fn = (x+y) =&amp;gt; {console.log(1),return x+y;}()起来js会认为是一个整体fn = name =&amp;gt; ({name:&#39;chengjian&#39;})用构造函数let f = new Function(&#39;x&#39;,&#39;y&#39;,&#39;return x+y&#39;)基本没人用，但是能让你知道函数是谁构造的所有的函数都是Function构造出来的包括Object、Array、Function也是2.调用时机 代码1(定时器是异步,它需要等待同步执行完后执行)let在外头,每次for循环,每次循环都是一个作用域,新的值都会覆盖外面let的值let i = 0;for(i = 0;i &amp;lt; 6;i++){setTimeout(()=&amp;gt;{console.log(i)});}let在里头,每次for循环都会形成一个let的作用域,循环多少次就会有多少个作用域for(let i = 0;i &amp;lt; 6;i++&amp;gt;){setTimeout(()=&amp;gt;{console.log(i)});}3.作用域:就近原则 &amp;amp; 闭包 作用域 : 每个函数执行都会形成一个私有作用域</description>
    </item>
    
    <item>
      <title>24 - [JS全解]字符串中API</title>
      <link>http://yaochengjian.com/posts/24/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/24/</guid>
      <description>分割字符串 split(获得一个数组)   let str = &#39;1,2,3,4,5,6&#39;;let arr1 = str.split(&#39;,&#39;); 以&#39;,&#39;号形式分割let arr2 = str.split(&#39;&#39;); 以&#39;&#39;形式分割拼接字符串 concat(获得新的字符串)   let str1 = &#39;abcd&#39;;let str2 = &#39;efgh&#39;;let str3 = str1.concat(str1);截取字符串 substring(获得新的字符串)   let str1 = &#39;你好啊!我的名字叫~~~&#39;;let str2 = str1.substring(0,1); 索引0开始,截取到索引1(不包括索引1)let str3 = str1.substring(3,6); 索引0开始,截取到索引1(不包括索引1)截取字符串 slice   let str1 = &#39;ABCDEFG&#39;;let str2 = str1.slice(0) 拷贝字符串let str3 = str1.slice(2,5) 索引2开始，到索引5结束(不包括索引5)返回指定位置的字符串 charAt   let str1 = &#39;ABCEDFG&#39;;let s = str1.</description>
    </item>
    
    <item>
      <title>25 - [JS全解]JS运算符</title>
      <link>http://yaochengjian.com/posts/25/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/25/</guid>
      <description>1.算术运算符 number 运算
1.加减乘除(+ - * /)2.取余(%)3.指数(**)7 ** 2 =&amp;gt; 七的平方7 *** 3 =&amp;gt; 七的三次方4.自增自减自增在后,先赋值,后计算自增在前,先计算,后赋值x++x--++x--x5.求值运算符+6.负数运算符-string 运算
1.字符串只支持一个 + 号的运算,其它符号都不支持2.任何东西+字符串都 = 字符串</description>
    </item>
    
    <item>
      <title>26 - [JS全解]JS各种类型转换机制</title>
      <link>http://yaochengjian.com/posts/26/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/26/</guid>
      <description>1.Number 和 isNaN 类型详细解读 数据类型详细剖析
1.Number (null &#39;&amp;rsquo; &#39; &#39; false [])转了都是 0
Number(&amp;lsquo;13px&amp;rsquo;) Number 如果当前字符串出现任意一个非有效数字字符,结果都为 NaN
2.isNaN 检测机制(数字类型只有 NaN 不是有效数字,其余都是有效数字)
Number 转换也是这种机制
首先会检测当前值是否为数字类型,如果不是,浏览器会默认把值转换为数字类型1.基本类型转换为数字 : 直接使用Number这个方法转换2.引用类型值转换为数字 : 先用toString()转换为数字,然后再把字符串调取Number转换为数字-对象 : 所有对象toString都是 &#39;[object object]&#39;-函数 : (function fn(){}).toString() -&amp;gt; &#39;function fn(){}&#39;-数组 : [12].toString() -&amp;gt; &#39;12&#39; -&amp;gt; Number(&#39;12&#39;) -&amp;gt; 12[12,13].toString() -&amp;gt; &#39;12,13&#39; -&amp;gt; Number(&#39;12,13&#39;) -&amp;gt; NaN-正则 : /^89$/.toString() -&amp;gt; &#39;/^89$/&#39; -&amp;gt; Number(&#39;/^89$/&#39;) -&amp;gt; NaN2.parseInt / parseFloat 1.</description>
    </item>
    
    <item>
      <title>27 - [JS编程接口]DOM编程</title>
      <link>http://yaochengjian.com/posts/27/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/27/</guid>
      <description>1.获取元素的 API 1.window.idxxx 或者直接 idxxx 一个标签拥有 id,直接用这种方式就可以获取
2.document.getElementById(&amp;lsquo;xxx&amp;rsquo;) 通过 id 获取该标签
3.document.getElementsByTagName(&amp;lsquo;div&amp;rsquo;) 通过标签获取属性,是一个伪数组
4.document.getElementsByClassName(&amp;lsquo;red&amp;rsquo;) 通过类获取该标签,是一个伪数组
5.document.querySelector(&#39;#id&amp;rsquo;)
6.document.querySelectorAll(&#39;.red&amp;rsquo;)
2.获取特定元素 1.获取html元素document.documentElement2.获取head元素document.head3.获取body元素document.body4.获取窗口(窗口不是元素,是一个对象)window5.获取所有元素(第六个falsy值)因为这个东西是ie发明的,在ie里面是真值,其它浏览器是假值document.all3.节点 1. element.nodeType 得到一个数字2. 1表示元素Element,也叫标签Tag3. 3表示文本Text4. 8表示注释Comment5. 9表示文档document记住2和3即可4.节点的增删改查 1.增加
1.创建一个标签节点let div1 = document.createElement(&#39;div&#39;);2.创建一个文本节点text1 = document.createTextNode(&#39;你好&#39;);3.标签里面插入文本div1.appendChild(text1); 如果页面本来存在标签,会擦掉在插入你想要位置div1.innerText = &#39;你好&#39; 或者 div1.textContent = &#39;你好&#39;但是不能用div1.appendChild(&#39;你好&#39;)2.删除
1.两种方法node.prototype提供方法(必须要父亲来删除)let div1 = document.</description>
    </item>
    
    <item>
      <title>28 - [JS编程接口]手写DOM库</title>
      <link>http://yaochengjian.com/posts/28/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/28/</guid>
      <description>1.classList用法node.classList.add(&#39;container&#39;) 添加一个类名node.classList.remove(&#39;container&#39;) 删除一个类名node.classList.contains(&#39;container&#39;) 判断是否含有这个类名1.insertBeforenode.insertBefore(newNode,oldNode) 把newNode插入oldNode节点前面3.appendChildparentNode.appendChild(node) 在某个容器插入节点,如果页面已经存在,会抹掉在添加4.removeChildparentNode.removeChild(node) 删除节点github 地址 : dom 封装</description>
    </item>
    
    <item>
      <title>29 - [JS编程接口]jQuery中的设计模式</title>
      <link>http://yaochengjian.com/posts/29/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/29/</guid>
      <description>1.链式风格(也叫 JQuery 风格) 1.window.jQuery()是提供的全局函数
2.jQuery(选择器)用于获取对应的元素
3.但是它却不返回这些元素,返回一个对象(jQuery 构造出来的对象)
4.这个对象可以操作对应的元素
&amp;lt;body&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好1&amp;lt;/div&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好2&amp;lt;/div&amp;gt;&amp;lt;div id = &#39;test&#39;&amp;gt;你好3&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt;window.jQuery = function(seletor){const element = document.querySeletorAll(seletor);return {addClassName(className){for(let i = 0;i &amp;lt; element.length;i++){element[i].classList.add(className);}}return this;}}&amp;lt;/script&amp;gt;2.命名风格 1.如果是通过 jQuery 获取过来的就用 $ 命名开头
2.不是 jQuery 获取过来的就不用
 let div = document.querySelector(&#39;#div&#39;);let $div = jQuery(&#39;#div&#39;); 返回来是一个对象(api)</description>
    </item>
    
    <item>
      <title>30 - [JS编程接口]使用jQuery</title>
      <link>http://yaochengjian.com/posts/30/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/30/</guid>
      <description>1.如何使用 jQuery 1.获取网页元素(&amp;hellip;)
1. $(document) 选择整个文档对象2. $(&#39;div&#39;) 获取页面div的元素3. $(&#39;div.myClass&#39;) 选择class为myClass的div元素4. $(&#39;input[name=first]&#39;) 选择name属性等于first的input元素2.筛选
1. $(&#39;div&#39;).has(&#39;p&#39;) 选择div包含p的元素2. $(&#39;div&#39;).not(&#39;.myClass&#39;) 选择class不等于myClss的div元素3. $(&#39;div&#39;).filter(&#39;.myClass&#39;) 选择class等于myClass的div元素4. $(&#39;div&#39;).first(&#39;.myClass&#39;) 选择第1个div元素5. $(&#39;div&#39;).find(&#39;p&#39;).eq(3) div子下第3个p元素3.找后面或者父级或者儿子元素&amp;hellip;
1. $(&#39;div&#39;).next(&#39;p&#39;) 选择div元素后面的第一个p元素2. $(&#39;div&#39;).parent() 选择div元素的父元素3. $(&#39;div&#39;).children() 选择div的所有子元素4. $(&#39;div&#39;).siblings() 选择div的兄弟元素4.jQuery 还提供 .end() 方法,回退到上一个对象上面
 $(&#39;div&#39;).find(&#39;h3&#39;).eq(2).html(&#39;hello&#39;).end() 退回到选中所有的h3元素的那一步.eq(0) 选中第1个h3元素.html(&#39;World&#39;) 将它内容改为World5.元素的操作 : 取值和赋值
1. $(&#39;h1&#39;).html() html()没有参数,表示取出h1的值2. $(&#39;h1&#39;).html(&#39;hello&#39;) html()有参数hello,表示更改h1里面内容常见取值和赋值函数如下:1. .</description>
    </item>
    
    <item>
      <title>31 - [项目]前端导航站点</title>
      <link>http://yaochengjian.com/posts/31/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/31/</guid>
      <description>1.onbeforeunload 当窗口即将被关闭,会触发该事件
2.JSON.stringify() 把一个对象变成 JSON 对象形式的字符串
let obj = [1,2,3];JSON.stringify(obj);3.JSON.parse() 把一个 JSON 对象形式字符串变成一个对象
let str = &#39;[0:1,1:2]&#39;;JSON.parse(str);4.localStorage 是本地存储(永久性),解决 cookie 存储空间不足的问题
localStorage.setItem(key,value) 把值以字符串的形式存储在本地 localStorage.getItem(key) 把存储在本地的值取出来
let str = &#39;123456&#39;;localStorage.setItem(&#39;x&#39;,str)localStorage.getItem(&#39;x&#39;);</description>
    </item>
    
    <item>
      <title>32 - [前后分离]AJAX的原理</title>
      <link>http://yaochengjian.com/posts/32/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/32/</guid>
      <description>1.背景 1.AJAX 是浏览器上的功能
2.浏览器可以发请求,收响应
3.浏览器在 window 上加了一个 XMLHttpRequest 函数
4.用这个构造函数可以构造出一个对象
5.JS 通过它实现发请求,收响应
2.node-dev 代替 node 命令 : npm install -g node-dev
1.方便我们开发
2.修改代码会自动帮我们重启
使用 : node-dev &amp;hellip;&amp;hellip;
3.AJAX  1. let xml = new XMLHttpRequest();2. xml.open(method , url ,async) method请求的方式(&#39;GET&#39;/&#39;POST&#39;), 请求的url地址 , async是true请求则是异步进行,false则是同步进行3. xml.setRequesHeader() 设置请求的头部4. xml.onreadystatechange = function(){} 只要xml.readyState的值变化,就会触发该事件函数5. xml.readyState 属性( 0 ~ 4)0 : 未调用open()方法1 ：open()方法已经被调用2 : send()方法已经被调用3 ：responseText属性已经包含部分数据4 ：已经接收全部数据6.</description>
    </item>
    
    <item>
      <title>33 - [前后分离]异步与Promise</title>
      <link>http://yaochengjian.com/posts/33/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/33/</guid>
      <description>1.什么是同步?什么是异步? 1.要理解什么是异步 JavaScript,我们应该从确切理解同步 JavaScript 开始
2.前面学的很多知识基本上都是同步的 &amp;ndash; 运行代码,然后浏览器尽快返回结果,先看一个简单的例子
const btn = document.querySelector(&#39;button&#39;);btn.addEventListener(&#39;click&#39;,()=&amp;gt;{alert(&#39;You clicked me!&#39;);let pElem = document.createElement(&#39;p&#39;);pElem.textContent = &#39;This is a newly-added paragraph.&#39;;document.appendChild(pElem);});这段代码,一行一行的顺序执行:
1.先取得一个 DOM 里面的 button 引用
2.点击按钮的时候,添加一个 click 事件监听
1.alert()消息出现(一直没有点击 alert 消息框,其它事情都阻塞,知道前面操作完成)
2.一但 alert 结束,创建一个 p 元素
3.给它的文本内容赋值
4.最后,把这个段落放进网页
2.Promise 1.它是 ES6 中新增加的类(new Promise),目的是为了管理 JS 中的异步编程的,所以我们也把它称为&#39;Promise&#39;设计模式
1. 三个状态 ：pending(准备:初始化成功,开始执行异步的任务)fulfilled(成功)rejected(失败)new Promise((resolve,reject)=&amp;gt;{=&amp;gt; 这里面一般执行一个异步的任务(new Promise的时候,创建Promise的实例,立即会把当前函数体中的异步操作执行)=&amp;gt; &#39;Promise是同步编程的,它可以管理异步操作&#39;=&amp;gt; resolve : 当异步操作执行成功,我们执行resolve方法=&amp;gt; reject : 当异步操作执行失败,我们执行reject方法setTimeout(()=&amp;gt;{resolve(100);},1000);}).</description>
    </item>
    
    <item>
      <title>34 - [前后分离]跨域、CORS、JSONP</title>
      <link>http://yaochengjian.com/posts/34/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/34/</guid>
      <description>1.跨域关键知识 1.同源策略(浏览器故意设计的一个功能限制)
2.CORS(突破浏览器限制的一个方法)
3.JSONP(IE 时代的妥协)
2.同源策略 1.源
window.origin 或 location.origin 可以得到当前源
源 = 协议 + 域名 + 端口号
2.如果两个 url 的协议、域名、端口号 完全一致,那么这两个 url 就是同源
3.同源策略定义
1.浏览器规定a. 如果JS运行在源A里,那么就只能获取源A的数据,不能获取源B的数据,即不允许跨域2.举例a. 假设frank.com/index.html 引用了cdn.com/1.jsb. 那么就说 [1.js 运行在源frank.com里]c. 注意这跟cdn.com没有关系,虽然1.js从它那下载d. 所以1.js就只能获取frank.com的数据d. 不能获取1.frank.com 或者 qq.com 的数据3.这是浏览器的功能!浏览器故意要这样设计的4.同源策略的目的是为了保护用户隐私,安全隐私4.其他疑问
1.为什么a.qq.com 访问 qq.com也算跨域、答 : 因为历史上,出现过不同公司共用域名。a.qq.com 和 qq.com 不一定是同一个网站,浏览器谨慎起见,认为这是不同的源2.为什么不同端口也算跨域?答 : 原因同上,一个端口一个公司。任何安全相关的问题都要谨慎对待3.为什么两个网站的ip是一样的,也算跨域?答 : 原因同上,ip可以共用4.为什么可以跨域使用CSS、JS和图片等?答 : 同源策略限制的是数据访问,我们引用CSS、JS和图片的时候,其实并不知道其内容,我们只是在引用3.解决方法一 : CORS (ie6,7,8,9 不支持) 1.</description>
    </item>
    
    <item>
      <title>35 - [前后分离]Node.js</title>
      <link>http://yaochengjian.com/posts/35/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/35/</guid>
      <description>1.什么是 node.js 1.简单的说 node.js 就是运行在服务端的 JavaScript
2.如果你是一个前端程序员,你不懂得 PHP、Python 等动态编程语言,然后你想创建自己的服务器,那么 node.js 是一个非常好的选择
2.怎么使用 1.require : 我们可以用 require 指令来载入 node.js 模块
require(&amp;ldquo;http&amp;rdquo;);
1. var http = require(&amp;quot;http&amp;quot;); 载入http模块,并将实例化HTTP赋值给变量http2. http对象下面有哪些方法1.http.listen() 接收一个数值参数,指定这个HTTP服务器监听的端口号2.http.createServer(function(request,response){request : 是一个请求对象,里面有请求属性整合1.request.url 获取请求的url/后面的域名(/index)2.request.method 获取请求的方式3.request.on(&amp;quot;data&amp;quot;,(data)=&amp;gt;{}) 当服务端接收到数据时触发4.request.on(&amp;quot;end&amp;quot;,()=&amp;gt;{}); 当服务端接收完数据时触发5.获取cookierequest.headers[&#39;cookie&#39;]response : 是一个响应对象,里面有响应属性整合1.response.statusCode = 200 设置响应状态码2.response.setHeader(&#39;Content-Type&#39;,&#39;text/css;charset=utf-8&#39;) 设置响应头的文件类型3.response.write(&#39;二哈&#39;) 设置响应回去的内容4.response.end() 响应结束,里面可以发送响应的数据5.设置cookieresponse.setHeader(&amp;quot;Set-Cookie&amp;quot;,&amp;quot;name=value&amp;quot;);});3.require(&amp;lsquo;fs&amp;rsquo;); fs 模块用于对系统文件及目录进行读写操作
 var fs = require(&#39;fs&#39;);1.fs.readyFileSync(&amp;quot;文件路径&amp;quot;,&amp;quot;编码格式&amp;quot;) 获取这个文件的内容,是一个字符串2.</description>
    </item>
    
    <item>
      <title>37 - [前后分离]Ajax实战:Cookie、Session</title>
      <link>http://yaochengjian.com/posts/36/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/36/</guid>
      <description>1.什么是动态服务器 1.是否请求了数据库
a. 没有请求服务器就是静态服务器
b. 请求了数据库就是动态服务器
2.目标 1 1.实现用户注册功能
a. 用户提交用户名和密码
b. users.json 里就新增一行数据
2.思路
a. 前端写一个 form,让用户填写 name 和 password
b. 前端监听表单事件
c. 前端发送 post 请求,请求位于请求体
d. 后端获取请求体中的 name 和 password
e. 后盾存储数据</description>
    </item>
    
    <item>
      <title>38 - MVC</title>
      <link>http://yaochengjian.com/posts/37/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/37/</guid>
      <description>1.MVC 是啥? a.每个模块都可以写成三个对象,分别是 M、V、C
b.M - Model(数据模型)负责操作所有数据
c.V - View(视图)负责所有 UI 界面
d.C - Controller(控制器)负责其他
2.为什么要有设计模式 a.代码重复太多,相同的页面重复写等。MVC 设计模式就是为了解决代码重复，优化代码结构
3.不学 MVC 会有什么情况 a.会出现意大利面条式代码的情况,过于臃肿太长,代码重复率高,页面不整洁等
b.你会变成类似外包程序员,每天重复干着重复的事情,不懂得提升自己,不会封装,不会造轮子
4.用 yarn | 或者 npm 引入 jQuery 1.yranyarn init -v 最好初始化一下yarnyarn add jquery2.npmnpm i jquery然后在js里面 inport $ from &amp;quot;jquery&amp;quot;2.jquery 中的 api
1.trigger(&#39;click&#39;) 自动点击事件$(&amp;quot;li&amp;quot;).trigger(&amp;quot;click&amp;quot;);2.toggleClass(类名,boolean) boolean可以加可不加(true则添加,false则不添加),如果该元素含有此类则删除,没有则添加$(&amp;quot;li&amp;quot;).toggleClass(&#39;active&#39;);3.prependTo() 把一个元素插入到父元素里面的前面$(&#39;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#39;).prependTo($(&amp;quot;#father&amp;quot;));5.简单认识 EventBus 1.什么是 EventBus
EventBus 可以使用监听和触发事件,对所有点实现通信
2.监听和触发两个 API
eventBus.trigger(&#39;click&#39;);eventBus.on(&#39;click&#39;,(){console.log(&amp;quot;我触发了&amp;quot;)})</description>
    </item>
    
    <item>
      <title>39 - webpack</title>
      <link>http://yaochengjian.com/posts/38/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/38/</guid>
      <description>1.安装 webpack 1.npm info webpack 可以打印出 webpack 的所有信息
2.npm install webpack -g 在全局安装 webpack
3.npm uninstall -g webpack 在全局卸载 webpack
2.webpack 是干嘛用的? 1.转译代码(ES6 转 ES5)
2.构建 build
3.代码压缩
4.代码分析
3.用 webpack 生成 js 1.mkdir webpack-demo (文件名可修改)
2.cd webpack-demo
3.npm init -y
4.npm install webpack webpack-cli &amp;ndash;save-dev(安装依赖,在本地安装)
5.创建一个 src 目录,目录下创建一个 index.js
6../node-modules/.bin/webpack 或者使用 npx webpack 运行本地目录 webpack
4.如何消除警告(WARNING in configuration&amp;hellip;) 1.在目录加上 webpack.config.js 文件(添加以下代码)
module.exports = {mode : &#39;development&#39; development开发模式,production是用户模式(切换模式)}2.</description>
    </item>
    
    <item>
      <title>39 - vue全解(起手式0)</title>
      <link>http://yaochengjian.com/posts/39/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/39/</guid>
      <description>1.使用 @vue/cli 搭建项目 a: @vue/cli 是什么?
答: @vue/cli 是 vue 的命令行工具,只要按照官网敲几行命令就可以新建一个基本的 vue 项目框架
b: 安装@vue/cli 与卸载@vue/cli
安装: npm install -g @vue/cli 或 yarn global add @vue/cli
卸载: npm uninstall @vue-cli -g 或 yarn global remove @vue/cli
c: @vue/cli 和 webpack 是什么关系?
答: @vue/cli 里面包含了 webpack,并且配置好了基本的 webpack 打包规则
d: 通过 vue create vue-demo 命令创建一个新项目
e: 进入该目录,yarn serve 开启预览
2.vue.js 完整版和运行时版本区别 完整版 vue.js
a.同时包含编译器和非完整版的版本如果你需要在客户端编译模板(比如传入一个字符串给template选项,或挂载一个元素并以其 DOM 内部的 HTML 作为模板),就将需要加上编译器,即完整版:
 &amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{n}}&amp;lt;/div&amp;gt;vue.</description>
    </item>
    
    <item>
      <title>40 - vue全解(起手式1)</title>
      <link>http://yaochengjian.com/posts/40/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/40/</guid>
      <description>1.Vue 简介 a: JavaScript 框架
b: 简化 Dom 操作
c: 响应式数据驱动
d: 开发环境版本(类似完整版的 jQuery),生成环境版本(类似 mini 版本的 jQuery)
e: 可以根据官方步骤来创建一个 vue 项目,也可以使用@vue/cli 来搭建
 1.导入开发版本的Vue.js2.创建Vue实例对象,设置el属性和data属性3.使用简洁的模板语法把数据渲染到页面上&amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{message}}&amp;lt;/div&amp;gt;&amp;lt;script src=&amp;quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;let vue = new Vue({el : &amp;quot;#app&amp;quot;,data : {message : &amp;quot;hello vue!&amp;quot;}});&amp;lt;/script&amp;gt;2.el:挂载点 a: Vue 实例的作用范围是什么呢?
答: Vue 会管理 el 选项命中的元素及内部的后代元素
 &amp;lt;div id = &amp;quot;app&amp;quot;&amp;gt;{{message}}&amp;lt;span&amp;gt;{{message}}&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script src=&amp;quot;https://cdn.</description>
    </item>
    
    <item>
      <title>50 - </title>
      <link>http://yaochengjian.com/posts/50/</link>
      <pubDate>Sat, 04 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/50/</guid>
      <description>去重let arr1 = [1,2,3,4,5,1,1,1,2,3,4],arr2.filter(function(item,index,arr){return arr.indexOf(item) === index;}); let arr1 = [1, 2];let arr2 = [1, 2, 3, 4];let arr3 = arr2.filter(function(item, index, array) {return arr1.indexOf(item) &amp;gt;= 0;});2. js 模块化 css.jslet string = &#39;12345&#39;export default string;main.jsimport string from &amp;quot;./css.js&amp;quot;</description>
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://yaochengjian.com/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Thu, 26 Dec 2019 21:51:11 +0800</pubDate>
      
      <guid>http://yaochengjian.com/posts/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      <description>姚成健 </description>
    </item>
    
    <item>
      <title>1 - 如何使用hugo搭建个人博客</title>
      <link>http://yaochengjian.com/posts/1/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0801</pubDate>
      
      <guid>http://yaochengjian.com/posts/1/</guid>
      <description>1.如何使用 hugo 搭建个人博客 a:进入https://gohugo.io/官网，下载并安装hugo
b:我的电脑-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量-&amp;gt;path-&amp;gt;添加你 hugo 的路径地址
c:hugo version 查看自己的版本,可以看到就代表自己 hugo 安装没问题
d:在 hugo 官网点击 Quick Start 根据步骤一步步实现(下面都是用命令行操作)
1)hugo new site demo(demo 可以更改为自己想要的名字)
2)cd demo 进入 demo
3)git init
4)git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
5)echo &amp;lsquo;theme = &amp;ldquo;ananke&amp;rdquo;&amp;rsquo; &amp;raquo; config.toml
6)hugo new posts/my-first-post.md(my-first-post 可以更改为自己想要的内容)
7)hugo server -D 可以得到一个预览地址
8)打开 config.toml 配置
baseURL = &amp;quot;yaochengjian.com&amp;quot; //更改为自己购买的域名languageCode = &amp;quot;zh-CN&amp;quot;title = &amp;quot;姚成健的博客&amp;quot;theme = &amp;quot;ananke&amp;quot;9)hugo -D
10)上面的完成之后，我们会看到 demo 里面有一个 public 文件名,我们也要在里面 git init 每次只需要提交这个文件里面的内容到 github 仓库即可！！！</description>
    </item>
    
    <item>
      <title>2 - Node &amp; yarn</title>
      <link>http://yaochengjian.com/posts/2/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0802</pubDate>
      
      <guid>http://yaochengjian.com/posts/2/</guid>
      <description>安装 node.js   安装双数版本
1.node8 node10 node12 是稳定版
2.尽量选择官网安装
3.下载慢就加入 FQ 插件的代理
  安装之后
1.自然就有了 node 命令(因为 PATH)
2.自然就有了 npm 命令
3.自然就有了 npx 命令
  配置 Node.js(因为 node.js 服务器默认在国外，我们需要用淘宝镜像服务器)
1.npm install -global nrm 缩写 npm i -g nrm
npm 是这个命令的开始
install 是载入意思
global 是全局意思
nrm 是一个 npm 源管理器，允许你快速地在 npm 源间切换
2.nrm ls 执行命令查看可选的源
其中带*号的是当前使用的源，如果要切换到 taobao 源，执行命令 nrm use taobao
3.npm config list 查看 nrm 所有配置
  </description>
    </item>
    
    <item>
      <title>3 - [Git入门]bash命令行入门</title>
      <link>http://yaochengjian.com/posts/3/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0803</pubDate>
      
      <guid>http://yaochengjian.com/posts/3/</guid>
      <description>1.文件查看操作 1.命令缩写，程序员把动词缩写，就变成了命令
2.查：查看文件或目录
 查看当前目录绝对路径
pwd
 查看当前目录内容
ls
查看指定目录内容
ls 目录名称
 查看文件内容
cat 文件名称(会显示全部内容)
head 文件名称(可以控制想看多少行，从开头开始显示)
tail 文件名称(可以控制想看多少行，从底部开始)
  2.文件的增加删除操作 1.touch 1.txt
确定你路径在哪里，创建一个文件
3.文件(创建 追加 复制 删除)内容 1.echo mmp &amp;gt; 1.txt
向 1.txt 里面追加内容，最新的命令行会覆盖以前追加的信息
2.echo mmp &amp;raquo; 1.txt
向 1.txt 里面追加内容，最新的命令行会叠加以前追加的信息
3.echo -e &amp;ldquo;1/n2&amp;rdquo; &amp;gt; 1.txt
向 1.txt 里面追加两行内容 4.mkdir demo-1
创建一个文件名字为 demo-1 的目录
mkdir -p a/b/c/d
创建多层目录
5.cp 1.txt 2.txt
复制 1.txt 内容为 2.txt
cp -r demo demo1</description>
    </item>
    
    <item>
      <title>4 - [Git入门]本地仓库</title>
      <link>http://yaochengjian.com/posts/4/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0804</pubDate>
      
      <guid>http://yaochengjian.com/posts/4/</guid>
      <description>1.git 就是开启 GitHub 的钥匙 2.git 的 6 行配置(必须存在，否则 git 无法使用) git config &amp;ndash;global user.name 你的英文名(yaochengjian)
git config &amp;ndash;global user.email 你的邮箱(915248459@qq.com)
git config &amp;ndash;global push.default simple
git config &amp;ndash;global core.quotepath false
git config &amp;ndash;global core.eaitor &amp;ldquo;code &amp;ndash;wait&amp;rdquo;
git config &amp;ndash;global core.autocrlf input
注意：上面的英文名和邮箱跟 Github 没有关系，可以跟 GitHub 的用户名和邮箱保持一致，也可以不一致
3.git 可以让你的代码有版本(可以随时回退到某个版本，当然 git 还有其它更强大的功能) 1.git init
会创建.git 目录/仓库，用来容纳你的代码快照
2.git add 路径
选择哪些变动是需要提交的，相对路径/绝对路径
3..gitignore
描述哪些变动是不需要提交的
4.git status
通过这个命令可以查看哪些文件需要提交的
5.git commit -m 字符串
把上面提交的代码复制一份到.git 目录里面
git commit -v</description>
    </item>
    
    <item>
      <title>5 - [Git入门]git远程仓库GitHub</title>
      <link>http://yaochengjian.com/posts/5/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0805</pubDate>
      
      <guid>http://yaochengjian.com/posts/5/</guid>
      <description>操控远程仓库 GitHub 1.如何生成 ssh key(需要在 github 上面填写公钥)
a. 运行 ssh-keygen -t rsa -b 4096 -C 你的邮箱
b. 一直回车，直至到没有提示
2.如何测试配对成功
a. ssh -T git@github.com
b. 如果问你 yes/no，请回答 yes 并回车
3.上传代码
a. 新建 GitHub Repo，赋值其 ssh 地址
b. git remote add origin git@xxxxxxxx
c. 在本地仓库添加远程仓库地址
d. origin 是远程仓库的默认名字，可以换，建议不要换
e. 不要使用https://地址，因为每次都需要密码
f. git push -u origin master 推送本地 master 分支到远程 origin 的 master 分支
4.如何下载代码
a. gitclone git@xxxx[目标路径] b. 如果是不同机器，要写上传新的 ssh key[一机一 key]</description>
    </item>
    
    <item>
      <title>6 - HTML入门笔记1</title>
      <link>http://yaochengjian.com/posts/6/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0806</pubDate>
      
      <guid>http://yaochengjian.com/posts/6/</guid>
      <description>1.HTML 是谁发明的 蒂姆·伯纳斯-李是第一个使用超文本来分享资讯，及于 1990 发明了首个网页浏览器&amp;ndash;WorldWideWeb 的人
2.HTML 起手式应该写什么 &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;&amp;lt;head&amp;gt;&amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1.0&amp;quot;/&amp;gt;&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie-edge&amp;quot;/&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;3.章节标签(表示文章/书的层级) -标题 h1~h6
-章节 section
-文章 article
-段落 p
-头部 header
-脚部 footer
-主要内容 main
-旁支分支 aside
-划分 div
4.全局属性(所有标签都有的属性) -class 类选择器
-contenteditable 页面实时编辑
-hidden 隐藏
-id 选择器 ID
-style 样式，行内样式
-tabindex 用来控制键盘 tab 顺序，从序号 1 开始，0 代表最后一个
-title 标题
5.内容标签 -ol+li 有序列表 ol 子集不能含有任何子元素或者中文</description>
    </item>
    
    <item>
      <title>7 - [HTML全解]HTML重难点</title>
      <link>http://yaochengjian.com/posts/7/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0807</pubDate>
      
      <guid>http://yaochengjian.com/posts/7/</guid>
      <description>1.像用户一样利用网址来打开网页 1)yarn global add parcel
2)parcel 1.a.html(文件名字)
1)yarn global add http-server
2)http-server
2.a 标签(属性) (1)href 取值
a:网址[https://google.com、http://google.com、//google.com]
b:路径[/a/b/c 或者 a/b/c]
c:伪协议[javascript:;代码、mailto:邮箱、tel:手机号]
d:id[href=&amp;rdquo;#xxx&amp;quot;定位锚文本为#xxx 标签]
网址&amp;lt;a href = &amp;quot;https://google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;https://google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;//google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;路径&amp;lt;a href = &amp;quot;/a/b/c&amp;quot;&amp;gt;相对路径&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;a/b/c&amp;quot;&amp;gt;绝对路径&amp;lt;/a&amp;gt;伪协议&amp;lt;a href = &amp;quot;javascript:;&amp;quot;&amp;gt;点击会跳转不了&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;mailto:915248459@qq.com&amp;quot;&amp;gt;邮箱&amp;lt;/a&amp;gt;&amp;lt;a href = &amp;quot;tel:13580466113&amp;quot;&amp;gt;电话&amp;lt;/a&amp;gt;锚文本定位&amp;lt;p id = &amp;quot;xxx&amp;quot;&amp;gt;1&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;2&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;3&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;4&amp;lt;/p&amp;gt;&amp;lt;a href = &amp;quot;#xxx&amp;quot;&amp;gt;会定位到id为#xxx上面去&amp;lt;/a&amp;gt;(2)target 属性值</description>
    </item>
    
    <item>
      <title>8 - [css全解]css基础</title>
      <link>http://yaochengjian.com/posts/8/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0808</pubDate>
      
      <guid>http://yaochengjian.com/posts/8/</guid>
      <description>1. 我怎么知道哪些浏览器兼容哪些特性呢？ a：几十种浏览器全部跑一遍
b：使用 caniuse.com
2.语法超级简单 语法 1
选择器{
属性名:属性值
/*这是一个注释*/
}
p{color:blue;background:red;}!注意事项 a：所有符号都是英文符号，如果写错了，浏览器会警告
b：区分大小写，a 和 A 是不同东西
c：最后一个分号可以省略，但建议不要省略
d：任何地方写错了，都不会报错，浏览器会直接忽略
语法 2：@语法
@charset &amp;ldquo;utf-8&amp;rdquo;;
@import url(2.css);
@media(min-width:100px) and (max-width:200px){ }
!注意事项 a：@charset 必须放在第一行
b：前面两个@语法必须以分号;结尾
c：charset 是字符集的意思，但是 utf-8 是字符编码
3.border 调试法 a：怀疑某个元素有问题就给这个元素加 border
b：border 没出现?说明选择器错了或者语法错了
c：bug 解决了才可以把 border 删掉
4.文档流 -流动方向 a：inline 元素从左到右，到达最右边才会换行
b：block 元素从上到下，每一个都另起一行
c：inline-block 也是从左到右，但是到达最后的时候不会把自己分为两块
-宽度
a：inline 宽度靠内部内容宽度撑开，不能用 width 指定
b：blcok 默认自动计算宽度，可用 width 指定
c：inline-block 结合前两者特点，可用 width</description>
    </item>
    
    <item>
      <title>9 - [css全解]布局</title>
      <link>http://yaochengjian.com/posts/9/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0809</pubDate>
      
      <guid>http://yaochengjian.com/posts/9/</guid>
      <description>1.布局分类 两种
a: 固定宽度布局，一般宽度为 960 、 1000 、 1024px
b: 不固定宽度布局，主要靠文档流的原理来布局
2.还记得吗? a: 文档流本来就是自适应的，不需要加额外的样式
&amp;lt;style&amp;gt;span{border:1px solid red;}&amp;lt;/style&amp;gt;//它本来就会根据你页面的宽度大小来自适应&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;2&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;3&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;5&amp;lt;/span&amp;gt;3.第三种布局 a: 响应式布局
b: 意思就是 pc 上固定宽度，手机上不固定宽度
c: 也就是一种混合布局
4.布局的两种思路 ① 从大到小
先定下大局
然后完善每个部分的小布局
② 从小到大
先完成小布局
然后组合成大布局
③ 两种均可
新人推荐用第二种，因为小的简单
老手一般用第一种，因为熟练有大局观
4.用什么 css 布局 5.float 布局 a: 步骤
-子元素上加 float:left/right 和 width
-在父元素上加.clearfix(必须要加上)
实践 不同布局
-用 float 做两栏布局(如顶部条)
-用 float 做三栏布局(内容区)</description>
    </item>
    
    <item>
      <title>10 - [css全解]定位</title>
      <link>http://yaochengjian.com/posts/10/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0810</pubDate>
      
      <guid>http://yaochengjian.com/posts/10/</guid>
      <description>问两个问题 -背景的范围是从哪到哪?(正确答案是 B)
A.border 内边沿围成的区域
B.border 外边沿围成的区域
-如何验证自己的猜想?border 半透明化
-从左边看一个 div,是什么样子?
新属性-position a：position
1.static 默认值，待在文档流里
2.relative 相对定位，升起来，但不脱离文档流
3.absolute 绝对定位，定位基准是祖先里的非 static
4.fixed 固定定位，定位基准是 viewport(有诈)
5.sticky 粘滞定位，不好描述直接举例
经验
1.如果你写了 absolute，一般都得补一个 relative
2.如果你写了 absolute 或 fixed，一定要补 top 和 left
3.sticky 兼容性很差，主要用于面试装逼
position:relative
a：使用场景
1.用于做位移对齐(很少用，现在都直接用 display:flex 了)
2.用于给 absolute 元素做爸爸
b：配合 z-index(z-index 必须配合 position 使用，否则不生效)
1.z-index:auto 默认值，不创建新层叠上下文
2.z-index：0 | 1 | 2
3.z-index:-1 | -2
经验
1.写 z-index:9999 的都是彩笔
2.学会管理 z-index
position:absolute
a：使用场景
1.脱离原来的位置，另起一层，比如对话框的关闭按钮</description>
    </item>
    
    <item>
      <title>11 - [css动画]</title>
      <link>http://yaochengjian.com/posts/11/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0811</pubDate>
      
      <guid>http://yaochengjian.com/posts/11/</guid>
      <description>transform 完整介绍 a: translate(平移)
 translateX(长度 | 百分比) translateY(长度 | 百分比) translate(x 轴,y 轴) translateX(50%) 往右边偏移自身宽度的一半  translate(-50%,-50%) 可做绝对定位元素居中
b: scale(缩放)
 scaleX(number) scaleY(number) scale(X-number,Y-number)  用得较少，因为容易出现模糊
c: rotate(旋转)
d: transform-origin 设置旋转点
 rotate(度数) 沿 Z 轴转动 rotateX(度数) rotateY(度数)  e: skew(倾斜)
 skewX(度数) skewY(度数) skew(X,Y)  用得较少
案例 爱心
transition 过渡 a: 语法
 transition-property 状态发生变化的属性(可以用 all 代表所有属性) transition-timing-function 过渡变化的速度 transition-delay 延迟多长时间开始 transition:width 3s , background 3s(这样我们可以采用多种属性一起过渡) 过渡方式有: ease : 速度逐渐变慢，这是默认值</description>
    </item>
    
    <item>
      <title>12 - [HTTP全解]URL是什么</title>
      <link>http://yaochengjian.com/posts/12/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0812</pubDate>
      
      <guid>http://yaochengjian.com/posts/12/</guid>
      <description>1.域名是什么 a: 域名实际上是 ip 的别称 知识点
  一个域名可以对应不同 IP
这个叫做均衡负载，防止一台机器扛不住
  一个 IP 可以对应不同域名
这个叫做共享主机，穷开发者会这么做
  域名和 IP 是怎么对应起来的？
通过 DNS
  当你输入 xiedaimala.com
  过程
-你的 Chrom 浏览器会向电信|联通提供的 DNS 服务器询问 xiedaimala.com 对应 IP
-电信|联通会回答一个 IP(具体过程很复杂，不研究)
-然后 Chrome 才会想对应 IP 的 80/443 端口发送请求
-请求内容是查看 xiedaimala.com 的首要
为什么是 80 或 443 端口
-服务器默认用 80 提供 http 服务
-服务器默认用 443 提供 https 服务
-你可以在开发者工具里看到具体的端口
如何请求不同的页面
-路径可以做到(不同的路径可以请求不同的页面)
同一个页面，不同内容</description>
    </item>
    
    <item>
      <title>13 - [HTTP全解]请求和响应 &amp; Node.js server</title>
      <link>http://yaochengjian.com/posts/13/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0813</pubDate>
      
      <guid>http://yaochengjian.com/posts/13/</guid>
      <description>演示 Node.js Server   前置条件
-安装 Node.js 8 +
-理解 IP 和端口
-理解 URL 路径和查询参数
  如何发请求
-用 Chrome 地址栏
-用 curl 命令
  模拟客户端向服务器端请求内容
-在 github.com/FrankFang/nodejs-test/blob/master/server.js 下载
-一般这个文件是放在服务器上面，而不是自己的机器上
  response.setHeader(&amp;ldquo;Content-Type&amp;rdquo;,&amp;ldquo;text/css;charset=utf-8&amp;rdquo;) 让服务器告诉浏览器它发送的数据属于什么文件类型
response.write() 写入响应内容发送回给浏览器
response.end() 响应结束
  HTTP 基础概念   请求(Request Headers)[get 是获取内容，post 是上传内容]
-请求动词 路径 + 查询参数 协议名/版本 [请求行]
-Host: 域名或 IP [这三行是请求头]
Accept: text/html
Content-Type: 请求体的格式
-请求体[也就是上传的内容]
curl -v -X POST &amp;ndash;data &amp;lsquo;上传内容&amp;rsquo; http://localhost:8888/</description>
    </item>
    
    <item>
      <title>14 - [JS全解]JS的诞生</title>
      <link>http://yaochengjian.com/posts/14/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0814</pubDate>
      
      <guid>http://yaochengjian.com/posts/14/</guid>
      <description>1.Javascript 的 10 个设计缺陷  不适合开发大型程序 非常小的标准库 null 和 undefined  null属于对象的一种，意思是该对象为空;undefined则是一种数据类型，表示未定义(typeof 出来是字符串类型)typeof null // objecttypeof undefined // undefined全局变量难以控制 自动插入行尾分号 加号运算符  + 号作为运算符，有两个含义，可以表示数字与数字的和，也可以表示字符与字符的连接console.log(1 + 10)console.log(&amp;quot;1&amp;quot; + 10)NaN(NaN 自己也不等于自己)  NaN === NaN //falseNaN !== NaN //true数据和对象区分(数组也属于对象) == 和 ===   == 只是判断两个值是否相等=== 不单单判断值是否相等，还判断两边类型是否相等基本类型的包装对象  Javascript有三种基本数据类型：字符串、数字和布尔值。它们都有相应的建构函数，可以生成字符串对象、数字对象和布尔值对象。new Boolean(false);new Number(1234);new String(&amp;quot;Hello World&amp;quot;);与基本数据类型对应的对象类型，作用很小，造成的混淆却很大。alert( typeof 1234); // numberalert( typeof new Number(1234)); // object2.</description>
    </item>
    
    <item>
      <title>15 - [JS全解]内存图与JS世界</title>
      <link>http://yaochengjian.com/posts/15/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0815</pubDate>
      
      <guid>http://yaochengjian.com/posts/15/</guid>
      <description>浏览器功能 1.发起请求，下载 HTML,解析 HTML，下载 CSS，解析 CSS，渲染界面,下载 JS，解析 JS，执行 JS 等
2.JS 是单线程的，一个页面只能开一个渲染引擎和 JS 引擎，线程不能在开线程
JS 原型 1.所有的函数(函数也是对象,函数也是类)数据类型都天生自带一个属性:prototype(原型),这个属性的值是一个对象
2.在浏览器给 prototype 开辟的堆内存中有一个天生自带的属性:constructor，这个属性存储的值是当前函数本身
Array.prototype.constructor === Array3.每一个对象都有一个__ proto__的属性，这个属性指向当前实例所属类的原型(如果不能确定是谁的实例，都是 Object 的实例)
4.每一个类把供实例调取的公共属性方法，存储到自己原型上(原型 prototype 的作用就是存储一些公共的属性和方法，供它的实例调取使用)
原型链__proto__
1.它是一种基于__proto__向上查找机制。当我们操作实例的某个属性或者方法的时候，首先找自己空间中私有的属性
2.找到了，则结束查找，使用自己私有的即可
3.没有找到，则基于__proto__找所属类的 prototype，如果找到就用这个公有的，如果没找到，基于原型上的__proto__向上查找，一直找到 Object.prototype 的原型为止，如果在没有，操作的属性或者方法不存在 </description>
    </item>
    
    <item>
      <title>16 - [JS全解]canvas实践</title>
      <link>http://yaochengjian.com/posts/16/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0816</pubDate>
      
      <guid>http://yaochengjian.com/posts/16/</guid>
      <description>Canvas(不能在 css 设置宽高[不支持]) 绘制矩形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.fillStyle = &amp;ldquo;black&amp;rdquo; 定义路径内容区域颜色
3.ctx.fillRect(x,y,width,height)
4.ctx.fill() 填充路径的内容区域生成实心图形
绘制三角形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.strokeStyle = &amp;lsquo;red&amp;rsquo; 定义描边内容区域颜色
2.ctx.beginPath() 绘制一个新的形状路径开始
3.ctx.moveTo(x,y)
4.ctx.lineTo(x,y)
5.ctx.stroke() 填充描边路径颜色
6.ctx.lineWidth 定义线的粗心状态
7.ctx.lineCap 每个点与点连接是圆的
绘制圆形
1.var ctx = canvas.getContext(&amp;lsquo;2d&amp;rsquo;)
2.ctx.fillStyle = &amp;lsquo;red&amp;rsquo;
3.ctx.beiginPath() 绘制一个新的形状路径开始
3.ctx.arc(x,y,半径，圆开始，弧度)
4.ctx.fill()
需要注意的细节 1.document.body.clientWidth : 获取 body 的宽度(小细节:body 的高度是根据内容高度撑开的)
2.document.body.clientHeigh : 获取 body 的高度
3.document.documentElement.clientWidth : 获取 HTML 的宽度
4.document.documentElement.clientHeight : 获取 HTML 的高度
var ctx = canvas.</description>
    </item>
    
    <item>
      <title>17 - [JS全解]JS语法</title>
      <link>http://yaochengjian.com/posts/17/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0817</pubDate>
      
      <guid>http://yaochengjian.com/posts/17/</guid>
      <description>1.JS 版本 历史版本
ES3，IE6 支持，总体评价 : 垃圾
ES5，总体评价 : 还是垃圾
ES6，大部分浏览器支持，总体评价 : 一半垃圾一半好
ES2019 与 ES6 差别不大
为什么说 ES6 一半垃圾
因为 ES 不能删除以前的特性，要兼容旧的网站
也就是说以前能运行的网站，以后都要能运行
对比 Python3 你就知道兼容的好处 : 稳定
2.表达式与语句 表达式
 1+2 表达式的值为 3 add(1,2)表达式的值为函数的返回值 console.log 表达式的值为函数本身 console.log(3) 表达式的值为多少? undefined  语句
 var a = 1 是一个语句  二者的区别
 表达式一般都有值，语句可能有也可能没有 语句一般会改变环境(声明、赋值) 上面两句话并不是绝对的  3.空格  大部分空格没有实际意义 只有一个地方不能加回车，那就是 return 后面，加了函数调用会返回一个 undefined SYntaxError : 语法错误  4.区块 block {把代码包在一起let a = 1;let b = 2;}常常与 if / for / while 合用</description>
    </item>
    
    <item>
      <title>18 - [JS全解]JS数据类型</title>
      <link>http://yaochengjian.com/posts/18/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0818</pubDate>
      
      <guid>http://yaochengjian.com/posts/18/</guid>
      <description>1.用 0~127 表示所有符号  48~57 表示数字符号 65~90 表示大写字母 97~122 表示小写字母  2.JS 中的数据类型(7 种)   数字 number
  字符串 string
1.写法&#39;你好&#39; 单引号&amp;quot;你好&amp;quot; 双引号`你好` 反引号2.转义&#39;it&#39;s ok&#39; js引擎会认为&#39;it&#39;就结束了，后面的看不懂&#39;it \&#39;s ok&#39; 这就是转义3.如果你想要在字符串里回车可以使用反引号``let s = `这样是可以的用反引号很容易做到`4.通过下标读取字符(下标是从0开始)let s = &#39;hello&#39;;s[0]; //&#39;h&#39;  布尔 bool
 1.五个falsy值(falsy就是相当于false但又不是false的值)分别是[undefined 、null、0、NaN、&#39;&#39;]  符号 symbol
  未定义 undefined
  空 null</description>
    </item>
    
    <item>
      <title>19 - [JS全解]JS对象</title>
      <link>http://yaochengjian.com/posts/19/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0819</pubDate>
      
      <guid>http://yaochengjian.com/posts/19/</guid>
      <description>1.对象 object 对象定义
无序的数据集合键值对的集合let obj = {&#39;name&#39; : &#39;chengjian&#39;,&#39;age&#39; : 18}let obj = new Object({&#39;name&#39; : &#39;chengjian&#39;})细节1.键名是字符串，不是标识符，可以包含任意字符2.引号可省略3.就算引号省略了，键名也还是字符串(重要)4.Object.keys(obj)可以得到obj的所有key变量作属性名
let p1 = &amp;quot;name&amp;quot;;let obj = {p1 : &#39;chengjian&#39;} 这样写，属性名为&#39;p1&#39;let obj = {[p1] : &#39;chengjian&#39;} 这样写，属性名为&#39;name&#39;1.不加[]的属性名会自动变成字符串2.加了[]则会当做变量求值3.值如果不是字符串，则会自动变成字符串2.对象增删改查 删除
 let obj = {a : chengjian}console.log(&#39;xxx&#39; in obj)1.不含属性名&#39;a&#39; in obj2.含有属性名，但是值为undefined&#39;a&#39; in obj &amp;amp;&amp;amp; obj.</description>
    </item>
    
    <item>
      <title>20 - [JS全解]JS对象分类</title>
      <link>http://yaochengjian.com/posts/20/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0820</pubDate>
      
      <guid>http://yaochengjian.com/posts/20/</guid>
      <description>1.堆内存与栈内存  let squareList = [];let widthList = [5,6,5,6,5,6]let squarePrototype = {getArea(){return this.width * this.width;}getLength(){return this.width * 4}}for(let i = 0;i &amp;lt; 12;i++&amp;gt;){squareList[i] = Object.create(squarePrototype);squareList[i].width = widthList[i]}2.new 关键字 大小写
1.所有构造函数(专门用于创建对象的函数)首字母大写
2.所有被构造出来的对象，首字母小写
 function Square(width){this.width = width;}Square.prototype.getArea = function(){return this.width * this.width;}Square.prototype.getLength = function(){return this.width * 4}let square = new Square(5);square.</description>
    </item>
    
    <item>
      <title>21 - [JS全解]JS对象继承</title>
      <link>http://yaochengjian.com/posts/21/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0821</pubDate>
      
      <guid>http://yaochengjian.com/posts/21/</guid>
      <description>1.继承(子类继承父类的属性和方法) 1.原型继承
2.call 继承
3.寄生组合继承
4.Es6 中 class 类实现继承
1.原型继承
a. 方式 : Son.prototype = new Person(),Person 的实例本身具备父类 Person 的私有属性和公有方法,子类 Son 的原型指向它,那么子类 B 的实例就可以找到这些属性方法了
b. 和传统后台语言的继承不一样,子类继承父类,并不是把父类的属性方法客隆一份给子类(这样处理子类和父类就没直接关系了),JS 中的原型继承是让子类和父类建立原型链接的机制,子类的实例调取父类原型上的方法,都是基于原型链的查找机制完成的 存在的问题 : 子类可以重写父类原型上的方法(重写),子类和父类还有关系的 Son.prototype.__proto__.getX = null 把父类 Person 原型上的 getX 重写为 null,Person 的其它实例也会受到影响
原型继承存在的问题:
1.父类实例私有的属性以及公有的属性都变为了子类实例的公有属性
2.如果子类 Son 的原型上之前有属性方法,之前的方法都没有了
=&amp;gt; 原型继承 : 让子类的原型指向父类的一个实例function Person(){this.name = &#39;chengjian&#39;;}Person.prototype = {constructor : A,getX : function(){console.log(this.x);}}function Son(){this.age = 18;}Son.</description>
    </item>
    
    <item>
      <title>22 - [JS全解]JS数组</title>
      <link>http://yaochengjian.com/posts/22/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0822</pubDate>
      
      <guid>http://yaochengjian.com/posts/22/</guid>
      <description>1.JS 数组 1.创建一个数组let arr = [1,2,3];let arr = new Array(1,2,3);let arr = new Array(3) 只有一个参数时候length长度为32.转化let arr = &#39;1,2,3&#39;.split(&#39;,&#39;) 以逗号为分割成为一个数组let arr = &#39;123&#39;.split(&#39;&#39;) 以空字符串形式分割成为一个数组let arr = Array.from(&#39;abc&#39;) 需要满足(是否有下标，是否有length属性)有就可以尝试变成数组3.把伪数组变成数组let divs = document.getElementsByTagName(&#39;div&#39;);let arrDiv = Array.from(divs);console.log(arrDiv);4.concat()合并数组let arr1 = [1,2,3];let arr2 = [4,5,6];arr.concat(arr2); 得出来是新的一个数组，不会改变原来数组5.slice()截取数组let arr1 = [1,2,3,4,5,6];let arr2 = arr.slice(2); =&amp;gt; [3,4,5,6] 会得到一个新的数组，不会改变原来数组let arr3 = arr.</description>
    </item>
    
    <item>
      <title>22-1 - [JS全解]Map 、 Set</title>
      <link>http://yaochengjian.com/posts/22-1/</link>
      <pubDate>Wed, 25 Dec 2019 21:55:11 +0823</pubDate>
      
      <guid>http://yaochengjian.com/posts/22-1/</guid>
      <description>1.Map([iterable]) 键值对为两个元素的数组例如:[1,&amp;lsquo;one&amp;rsquo;] 1.map 的实例属性和操作方法
&amp;mdash;-size : 返回成员总数
&amp;mdash;-set(key,value) : 添加新的键值
&amp;mdash;-has(key) : 是否有某个键
&amp;mdash;-get(key) : 读取某个对应的值
&amp;mdash;-delete(key) : 删除某个键
&amp;mdash;-clear() : 清空
2.map 实例遍历的方法
&amp;mdash;-keys() : 返回键名
&amp;mdash;-values() : 返回键值
&amp;mdash;-entires() : 返回键值对
&amp;mdash;-forEach() : 遍历所有成员
利用map实现去重let array = [1,2,3,5,1,2,3,4]let map = new Map();for(let i = 0;i &amp;lt; array.length;i++&amp;gt;){if(map.has(array[i])){continue;}else{map.set(array[i],true);}}let newAry = [...map.keys()]2.Set([iterable])对象允许你存储任何类型的唯一值(set 里面的值是唯一的) 方法和属性
&amp;mdash;-size : 返回 set 对象的个数</description>
    </item>
    
    <item>
      <title>1000 - 变量提升、闭包</title>
      <link>http://yaochengjian.com/posts/1000/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://yaochengjian.com/posts/1000/</guid>
      <description>1.一般都把 js 放到 body 的末尾 a:为什么？
b:放在 head 中可以不可以？如何放到 head 中也可以实现出放到 body 末尾的效果？
c:script 标签中有两个属性：defer / async,这两个属性是做什么的？
2.js 数据渲染机制及堆栈内存 a:基本类型(因为数据简单，之间在全局作用域开辟一个地址存储)
&amp;lt;!--1.变量提升(找var和函数(var开始定义是undefined、函数定义赋值是同时完成的))--&amp;gt;var a = 12;var b = a;b = 13;console.log(a);b:引用类型(因为数据复杂，所以会开辟一个堆内存来存储)
var ary1 = [12,23];var ary2 = ary1;ary2.push(100);console.log(ary1);A:栈内存:作用域
1.提供一个供 js 代码自上而下执行的环境(代码都是在栈内存中执行的)
2.由于基本数据类型比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存进去的
=&amp;gt;当栈内存被销毁，存储的那些基本值也都跟着销毁了
B:堆内存:引用值对应的空间
1.存储引用类型值(对象:键值对 函数:代码字符串)
=&amp;gt;当前堆内存稀释被销毁，那么这个引用值彻底没了
=&amp;gt;堆内存的释放：当堆内存没有被任何变量或者其它东西所占用，浏览器会在空闲的时候，自主进行内存回收，把所有不被占用的堆内存销毁掉
=&amp;gt;xxx = null 通过空对象指针 null 可以让原始变量(或者其它东西)谁都不指向，那么原有被占用内存就没有被东西占用了，浏览器就会销毁它</description>
    </item>
    
  </channel>
</rss>